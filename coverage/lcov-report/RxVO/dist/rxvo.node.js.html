<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for RxVO/dist/rxvo.node.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../index.html">All files</a> / <a href="index.html">RxVO/dist</a> rxvo.node.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">42.39% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>1322/3119</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">28.39% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>1080/3804</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">46.22% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>306/662</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">100% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>1/1</span>
      </div>
    </div>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet">1</td><td class="line-coverage quiet"><span class="cline-any cline-yes">4443x</span></td><td class="text"><pre class="prettyprint lang-js">exports.RxVO=function(e){var r={};function t(a){if(r[a])return r[a].exports;var o=r[a]={i:a,l:!1,exports:{}};return e[a].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=r,t.d=function(e,r,a){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:a})},t.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},t.n=function(e){var r=e&amp;&amp;e.__esModule?<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.default}</span>:</span>function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=62)}([function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r._rxvoDocs=r._schemaSignatures=r._oBuilders=r._observerPaths=r._observers=r._schemaHelpers=r._schemaOptions=r._validators=r._dirtyModels=r._ajvRef=r._mdRef=r._object=r.wf=r._exists=void 0;var a=t(61);r._exists=a.exists,r.wf={Fun:a.Fun,Obj:a.Obj,Str:a.Str},r._object=new WeakMap,r._mdRef=new WeakMap,r._ajvRef=new WeakMap,r._dirtyModels=new WeakMap,r._validators=new WeakMap,r._schemaOptions=new WeakMap,r._schemaHelpers=new WeakMap,r._observers=new WeakMap,r._observerPaths=new WeakMap,r._oBuilders=new WeakMap,r._schemaSignatures=new WeakMap,r._rxvoDocs=new WeakMap},function(e,r,t){(function(e,a){var o;!function(n){"object"==typeof r&amp;&amp;r&amp;&amp;r.nodeType,"object"==typeof e&amp;&amp;e&amp;&amp;e.nodeType;var s="object"==typeof a&amp;&amp;a;s.global!==s&amp;&amp;s.window!==s&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >s.self;</span>var i,u=2147483647,l=36,c=1,h=26,f=38,p=700,d=72,m=128,v="-",y=/^xn--/,g=/[^\x20-\x7E]/,P=/[\x2E\u3002\uFF0E\uFF61]/g,E={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input &gt;= 0x80 (not a basic code point)","invalid-input":"Invalid input"},b=l-c,w=Math.floor,_=String.fromCharCode;function <span class="fstat-no" title="function not covered" >S(</span>e){<span class="cstat-no" title="statement not covered" >throw new RangeError(E[e])}</span>function x(e,r){for(var t=e.length,a=[];t--;)a[t]=r(e[t]);return a}function R(e,r){var t=e.split("@"),a="";return t.length&gt;1&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a=t[0]+"@",e=t[1])</span>,a+x((e=e.replace(P,".")).split("."),r).join(".")}function <span class="fstat-no" title="function not covered" >O(</span>e){<span class="cstat-no" title="statement not covered" >for(var r,t,a=[],o=0,n=e.length;o&lt;n;)<span class="cstat-no" title="statement not covered" >(r=e.charCodeAt(o++))&gt;=55296&amp;&amp;r&lt;=56319&amp;&amp;o&lt;n?56320==(64512&amp;(t=e.charCodeAt(o++)))?a.push(((1023&amp;r)&lt;&lt;10)+(1023&amp;t)+65536):(a.push(r),o--):a.push(r);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>function <span class="fstat-no" title="function not covered" >j(</span>e){<span class="cstat-no" title="statement not covered" >return x(e,<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return e&gt;65535&amp;&amp;(r+=_((e-=65536)&gt;&gt;&gt;10&amp;1023|55296),e=56320|1023&amp;e),r+=_(e)}</span>).join("")}</span>function <span class="fstat-no" title="function not covered" >A(</span>e,r){<span class="cstat-no" title="statement not covered" >return e+22+75*(e&lt;26)-((0!=r)&lt;&lt;5)}</span>function <span class="fstat-no" title="function not covered" >F(</span>e,r,t){var a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(e=t?w(e/p):e&gt;&gt;1,e+=w(e/r);e&gt;b*h&gt;&gt;1;a+=l)<span class="cstat-no" title="statement not covered" >e=w(e/b);<span class="cstat-no" title="statement not covered" >r</span></span>eturn w(a+(b+1)*e/(e+f))}</span>function <span class="fstat-no" title="function not covered" >D(</span>e){var r,t,a,o,n,s,i,f,p,y,g,P=<span class="cstat-no" title="statement not covered" >[],</span>E=<span class="cstat-no" title="statement not covered" >e.length,</span>b=<span class="cstat-no" title="statement not covered" >0,</span>_=<span class="cstat-no" title="statement not covered" >m,</span>x=<span class="cstat-no" title="statement not covered" >d;<span class="cstat-no" title="statement not covered" ></span>for((t=e.lastIndexOf(v))&lt;0&amp;&amp;(t=0),a=0;a&lt;t;++a)<span class="cstat-no" title="statement not covered" >e.charCodeAt(a)&gt;=128&amp;&amp;S("not-basic"),P.push(e.charCodeAt(a));<span class="cstat-no" title="statement not covered" >f</span></span>or(o=t&gt;0?t+1:0;o&lt;E;){<span class="cstat-no" title="statement not covered" >for(n=b,s=1,i=l;o&gt;=E&amp;&amp;S("invalid-input"),((f=(g=e.charCodeAt(o++))-48&lt;10?g-22:g-65&lt;26?g-65:g-97&lt;26?g-97:l)&gt;=l||f&gt;w((u-b)/s))&amp;&amp;S("overflow"),b+=f*s,!(f&lt;(p=i&lt;=x?c:i&gt;=x+h?h:i-x));i+=l)<span class="cstat-no" title="statement not covered" >s&gt;w(u/(y=l-p))&amp;&amp;S("overflow"),s*=y;<span class="cstat-no" title="statement not covered" >x</span></span>=F(b-n,r=P.length+1,0==n),w(b/r)&gt;u-_&amp;&amp;S("overflow"),_+=w(b/r),b%=r,P.splice(b++,0,_)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn j(P)}</span>function <span class="fstat-no" title="function not covered" >$(</span>e){var r,t,a,o,n,s,i,f,p,y,g,P,E,b,x,R=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(P=(e=O(e)).length,r=m,t=0,n=d,s=0;s&lt;P;++s)<span class="cstat-no" title="statement not covered" >(g=e[s])&lt;128&amp;&amp;R.push(_(g));<span class="cstat-no" title="statement not covered" >f</span></span>or(a=o=R.length,o&amp;&amp;R.push(v);a&lt;P;){<span class="cstat-no" title="statement not covered" >for(i=u,s=0;s&lt;P;++s)<span class="cstat-no" title="statement not covered" >(g=e[s])&gt;=r&amp;&amp;g&lt;i&amp;&amp;(i=g);<span class="cstat-no" title="statement not covered" >f</span></span>or(i-r&gt;w((u-t)/(E=a+1))&amp;&amp;S("overflow"),t+=(i-r)*E,r=i,s=0;s&lt;P;++s)<span class="cstat-no" title="statement not covered" >if((g=e[s])&lt;r&amp;&amp;++t&gt;u&amp;&amp;S("overflow"),g==r){<span class="cstat-no" title="statement not covered" >for(f=t,p=l;!(f&lt;(y=p&lt;=n?c:p&gt;=n+h?h:p-n));p+=l)<span class="cstat-no" title="statement not covered" >x=f-y,b=l-y,R.push(_(A(y+x%b,0))),f=w(x/b);<span class="cstat-no" title="statement not covered" >R</span></span>.push(_(A(f,0))),n=F(t,E,a==o),t=0,++a}<span class="cstat-no" title="statement not covered" ></span>+</span></span>+t,++r}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn R.join("")}</span>i={version:"1.4.1",ucs2:{decode:O,encode:j},decode:D,encode:$,toASCII:function(e){return R(e,function(e){return g.test(e)?<span class="branch-0 cbranch-no" title="branch not covered" >"xn--"+$(e):</span>e})},toUnicode:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return R(e,<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return y.test(e)?D(e.slice(4).toLowerCase()):e}</span>)}</span>},void 0===(o=function(){return i}.call(r,t,r,e))||(e.exports=o)}()}).call(this,t(54)(e),t(53))},function(e,r,t){"use strict";function a(e,r,t){var a=t?" !== ":" === ",o=t?" || ":" &amp;&amp; ",n=t?"!":"",s=t?"":"!";switch(e){<span class="branch-0 cbranch-no" title="branch not covered" >case"null":<span class="cstat-no" title="statement not covered" >return r+a+"null";c</span></span>ase"array":return n+"Array.isArray("+r+")";case"object":return"("+n+r+o+"typeof "+r+a+'"object"'+o+s+"Array.isArray("+r+"))";case"integer":return"(typeof "+r+a+'"number"'+o+s+"("+r+" % 1)"+o+r+a+r+")";default:return"typeof "+r+a+'"'+e+'"'}}e.exports={copy:function(e,r){for(var t in r=r||{},e)r[t]=e[t];return r},checkDataType:a,checkDataTypes:function(e,r){switch(e.length){<span class="branch-0 cbranch-no" title="branch not covered" >case 1:<span class="cstat-no" title="statement not covered" >return a(e[0],r,!0);d</span></span>efault:var t="",o=n(e);for(var s in o.array&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >o.object&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >t=o.null?"(":"(!"+r+" || ",t+="typeof "+r+' !== "object")',delete o.null,delete o.array,delete o.object)</span>,o.number&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >delete o.integer,</span>o)t+=(t?" &amp;&amp; ":"")+a(s,r,!0);return t}},coerceToTypes:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(Array.isArray(r)){<span class="cstat-no" title="statement not covered" >for(var t=[],a=0;a&lt;r.length;a++){var n=<span class="cstat-no" title="statement not covered" >r[a];<span class="cstat-no" title="statement not covered" ></span>o[n]?t[t.length]=n:"array"===e&amp;&amp;"array"===n&amp;&amp;(t[t.length]=n)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.length)<span class="cstat-no" title="statement not covered" >return t}</span></span>else{<span class="cstat-no" title="statement not covered" >if(o[r])<span class="cstat-no" title="statement not covered" >return[r];<span class="cstat-no" title="statement not covered" >i</span></span>f("array"===e&amp;&amp;"array"===r)<span class="cstat-no" title="statement not covered" >return["array"]}</span></span>}</span>,toHash:n,getProperty:u,escapeQuotes:l,equal:t(4),ucs2length:t(52),varOccurences:function(e,r){r+="[^0-9]";var t=e.match(new RegExp(r,"g"));return t?t.length:0},varReplace:function(e,r,t){return r+="([^0-9])",t=t.replace(/\$/g,"$$$$"),e.replace(new RegExp(r,"g"),t+"$1")},cleanUpCode:function(e){return e.replace(c,"").replace(h,"").replace(f,"if (!($1))")},finalCleanUpCode:function(e,r){var t=e.match(p);t&amp;&amp;2==t.length&amp;&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >e=r?e.replace(m,"").replace(g,P):e.replace(d,"").replace(v,y))</span>;return(t=e.match(E))&amp;&amp;3===t.length?e.replace(b,""):e},schemaHasRules:function(e,r){if("boolean"==typeof e)return!e;for(var t in e)if(r[t])return!0},schemaHasRulesExcept:function(e,r,t){<span class="missing-if-branch" title="if path not taken" >I</span>if("boolean"==typeof e)<span class="cstat-no" title="statement not covered" >return!e&amp;&amp;"not"!=t;f</span>or(var a in e)if(a!=t&amp;&amp;r[a])return!0},toQuotedString:w,getPathExpr:function(e,r,t,a){return x(e,t?"'/' + "+r+(a?"":".replace(/~/g, '~0').replace(/\\//g, '~1')"):<span class="branch-1 cbranch-no" title="branch not covered" >a?"'[' + "+r+" + ']'":"'[\\'' + "+r+" + '\\']'")</span>},getPath:function(e,r,t){var a=w(t?"/"+R(r):<span class="branch-1 cbranch-no" title="branch not covered" >u(r))</span>;return x(e,a)},getData:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a,o,n,s;<span class="cstat-no" title="statement not covered" >if(""===e)<span class="cstat-no" title="statement not covered" >return"rootData";<span class="cstat-no" title="statement not covered" >i</span></span>f("/"==e[0]){<span class="cstat-no" title="statement not covered" >if(!_.test(e))<span class="cstat-no" title="statement not covered" >throw new Error("Invalid JSON-pointer: "+e);<span class="cstat-no" title="statement not covered" >o</span></span>=e,n="rootData"}</span>else{<span class="cstat-no" title="statement not covered" >if(!(s=e.match(S)))<span class="cstat-no" title="statement not covered" >throw new Error("Invalid JSON-pointer: "+e);<span class="cstat-no" title="statement not covered" >i</span></span>f(a=+s[1],"#"==(o=s[2])){<span class="cstat-no" title="statement not covered" >if(a&gt;=r)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot access property/index "+a+" levels up, current level is "+r);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t[r-a]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a&gt;r)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot access data "+a+" levels up, current level is "+r);<span class="cstat-no" title="statement not covered" >i</span></span>f(n="data"+(r-a||""),!o)<span class="cstat-no" title="statement not covered" >return n}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var i=n,l=o.split("/"),c=0;c&lt;l.length;c++){var h=<span class="cstat-no" title="statement not covered" >l[c];<span class="cstat-no" title="statement not covered" ></span>h&amp;&amp;(n+=u(O(h)),i+=" &amp;&amp; "+n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>,unescapeFragment:function(e){return O(decodeURIComponent(e))},unescapeJsonPointer:O,escapeFragment:function(e){return encodeURIComponent(R(e))},escapeJsonPointer:R};var o=n(["string","number","integer","boolean","null"]);function n(e){for(var r={},t=0;t&lt;e.length;t++)r[e[t]]=!0;return r}var s=/^[a-z$_][a-z$_0-9]*$/i,i=/'|\\/g;function u(e){return"number"==typeof e?<span class="branch-0 cbranch-no" title="branch not covered" >"["+e+"]":</span>s.test(e)?"."+e:"['"+l(e)+"']"}function l(e){return e.replace(i,"\\$&amp;").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/\f/g,"\\f").replace(/\t/g,"\\t")}var c=/else\s*{\s*}/g,h=/if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g,f=/if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;var p=/[^v.]errors/g,d=/var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g,m=/var errors = 0;|var vErrors = null;/g,v="return errors === 0;",y="validate.errors = null; return true;",g=/if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/,P="return data;",E=/[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g,b=/if \(rootData === undefined\) rootData = data;/;function w(e){return"'"+l(e)+"'"}var _=/^\/(?:[^~]|~0|~1)*$/,S=/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;function x(e,r){return'""'==e?r:(e+" + "+r).replace(/' \+ '/g,"")}function R(e){return e.replace(/~/g,"~0").replace(/\//g,"~1")}function O(e){return e.replace(/~1/g,"/").replace(/~0/g,"~")}},function(e,r,t){"use strict";var a=t(5);function <span class="fstat-no" title="function not covered" >o(</span>e,r,t){<span class="cstat-no" title="statement not covered" >this.message=t||o.message(e,r),this.missingRef=a.url(e,r),this.missingSchema=a.normalizeId(a.fullPath(this.missingRef))}</span>function n(e){return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}e.exports={Validation:n(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.message="validation failed",this.errors=e,this.ajv=this.validation=!0}</span>),MissingRef:n(o)},o.message=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return"can't resolve reference "+r+" from id "+e}</span>},function(e,r,t){"use strict";e.exports=function <span class="fstat-no" title="function not covered" >e(</span>r,t){<span class="cstat-no" title="statement not covered" >if(r===t)<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar a,o=<span class="cstat-no" title="statement not covered" >Array.isArray(r),</span>n=<span class="cstat-no" title="statement not covered" >Array.isArray(t);<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;n){<span class="cstat-no" title="statement not covered" >if(r.length!=t.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(a=0;a&lt;r.length;a++)<span class="cstat-no" title="statement not covered" >if(!e(r[a],t[a]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o!=n)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r&amp;&amp;t&amp;&amp;"object"==typeof r&amp;&amp;"object"==typeof t){var s=<span class="cstat-no" title="statement not covered" >Object.keys(r);<span class="cstat-no" title="statement not covered" ></span>if(s.length!==Object.keys(t).length)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >r instanceof Date,</span>u=<span class="cstat-no" title="statement not covered" >t instanceof Date;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;u)<span class="cstat-no" title="statement not covered" >return r.getTime()==t.getTime();<span class="cstat-no" title="statement not covered" >i</span></span>f(i!=u)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >r instanceof RegExp,</span>c=<span class="cstat-no" title="statement not covered" >t instanceof RegExp;<span class="cstat-no" title="statement not covered" ></span>if(l&amp;&amp;c)<span class="cstat-no" title="statement not covered" >return r.toString()==t.toString();<span class="cstat-no" title="statement not covered" >i</span></span>f(l!=c)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(a=0;a&lt;s.length;a++)<span class="cstat-no" title="statement not covered" >if(!Object.prototype.hasOwnProperty.call(t,s[a]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(a=0;a&lt;s.length;a++)<span class="cstat-no" title="statement not covered" >if(!e(r[s[a]],t[s[a]]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>},function(e,r,t){"use strict";var a=t(21),o=t(4),n=t(2),s=t(15),i=t(51);function u(e,r,t){var a=this._refs[t];<span class="missing-if-branch" title="if path not taken" >I</span>if("string"==typeof a){<span class="cstat-no" title="statement not covered" >if(!this._refs[a])<span class="cstat-no" title="statement not covered" >return u.call(this,e,r,a);<span class="cstat-no" title="statement not covered" >a</span></span>=this._refs[a]}</span>if((a=a||this._schemas[t])instanceof s)return p(a.schema,this._opts.inlineRefs)?a.schema:<span class="branch-1 cbranch-no" title="branch not covered" >a.validate||this._compile(a);</span>var o,n,i,c=l.call(this,r,t);return c&amp;&amp;(o=c.schema,r=c.root,i=c.baseId),o instanceof s?<span class="branch-0 cbranch-no" title="branch not covered" >n=o.validate||e.call(this,o.schema,r,void 0,i):</span>void 0!==o&amp;&amp;(n=p(o,this._opts.inlineRefs)?o:e.call(this,o,r,void 0,i)),n}function l(e,r){var t=a.parse(r),o=m(t),n=d(this._getId(e.schema));<span class="missing-if-branch" title="if path not taken" >I</span>if(o!==n){var i=<span class="cstat-no" title="statement not covered" >y(o),</span>u=<span class="cstat-no" title="statement not covered" >this._refs[i];<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof u)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >l.call(this,e,r);<span class="cstat-no" title="statement not covered" ></span>if(a){var o=<span class="cstat-no" title="statement not covered" >a.schema,</span>n=<span class="cstat-no" title="statement not covered" >a.baseId;<span class="cstat-no" title="statement not covered" ></span>e=a.root;v</span>ar s=<span class="cstat-no" title="statement not covered" >this._getId(o);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(n=g(n,s)),h.call(this,t,n,o,e)}</span>}</span>.call(this,e,u,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(u instanceof s)<span class="cstat-no" title="statement not covered" >u.validate||this._compile(u),e=u;e</span>lse{<span class="cstat-no" title="statement not covered" >if(!((u=this._schemas[i])instanceof s))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(u.validate||this._compile(u),i==y(r))<span class="cstat-no" title="statement not covered" >return{schema:u,root:e,baseId:n};<span class="cstat-no" title="statement not covered" >e</span></span>=u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!e.schema)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span></span>=d(this._getId(e.schema))}</span>return h.call(this,t,n,e.schema,e)}e.exports=u,u.normalizeId=y,u.fullPath=d,u.url=g,u.ids=function(e){var r=y(this._getId(e)),t={"":r},s={"":d(r,!1)},u={},l=this;return i(e,{allKeys:!0},function(e,r,i,c,h,f,p){if(""!==r){var d=l._getId(e),m=t[c],v=s[c]+"/"+h;<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0!==p&amp;&amp;(v+="/"+("number"==typeof p?p:n.escapeFragment(p))),"string"==typeof d){<span class="cstat-no" title="statement not covered" >d=m=y(m?a.resolve(m,d):d);v</span>ar g=<span class="cstat-no" title="statement not covered" >l._refs[d];<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof g&amp;&amp;(g=l._refs[g]),g&amp;&amp;g.schema){<span class="cstat-no" title="statement not covered" >if(!o(e,g.schema))<span class="cstat-no" title="statement not covered" >throw new Error('id "'+d+'" resolves to more than one schema')}</span></span>else <span class="cstat-no" title="statement not covered" >if(d!=y(v))<span class="cstat-no" title="statement not covered" >if("#"==d[0]){<span class="cstat-no" title="statement not covered" >if(u[d]&amp;&amp;!o(e,u[d]))<span class="cstat-no" title="statement not covered" >throw new Error('id "'+d+'" resolves to more than one schema');<span class="cstat-no" title="statement not covered" >u</span></span>[d]=e}</span>else <span class="cstat-no" title="statement not covered" >l._refs[d]=v}</span></span></span></span>t[r]=m,s[r]=v}}),u},u.inlineRef=p,u.schema=l;var c=n.toHash(["properties","patternProperties","enum","dependencies","definitions"]);function h(e,r,t,a){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.fragment=e.fragment||<span class="branch-1 cbranch-no" title="branch not covered" >"",</span>"/"==e.fragment.slice(0,1)){for(var o=e.fragment.split("/"),s=1;s&lt;o.length;s++){var i=o[s];<span class="missing-if-branch" title="else path not taken" >E</span>if(i){<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0===(t=t[i=n.unescapeFragment(i)]))<span class="cstat-no" title="statement not covered" >break;v</span>ar u;<span class="missing-if-branch" title="if path not taken" >I</span>if(!c[i]&amp;&amp;((u=this._getId(t))&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >r=g(r,u))</span>,t.$ref)){var h=<span class="cstat-no" title="statement not covered" >g(r,t.$ref),</span>f=<span class="cstat-no" title="statement not covered" >l.call(this,a,h);<span class="cstat-no" title="statement not covered" ></span>f&amp;&amp;(t=f.schema,a=f.root,r=f.baseId)}</span>}}return void 0!==t&amp;&amp;t!==a.schema?{schema:t,root:a,baseId:r}:<span class="branch-1 cbranch-no" title="branch not covered" >void 0}</span>}var f=n.toHash(["type","format","pattern","maxLength","minLength","maxProperties","minProperties","maxItems","minItems","maximum","minimum","uniqueItems","multipleOf","required","enum"]);function p(e,r){return!1!==r&amp;&amp;(void 0===r||<span class="branch-1 cbranch-no" title="branch not covered" >!0===r?</span>function e(r){var t;if(Array.isArray(r)){for(var a=0;a&lt;r.length;a++)if("object"==typeof(t=r[a])&amp;&amp;!e(t))return!1}else for(var o in r){if("$ref"==o)return!1;if("object"==typeof(t=r[o])&amp;&amp;!e(t))return!1}return!0}(e):<span class="branch-1 cbranch-no" title="branch not covered" >r?function <span class="fstat-no" title="function not covered" >e(</span>r){var t,a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(r)){<span class="cstat-no" title="statement not covered" >for(var o=0;o&lt;r.length;o++)<span class="cstat-no" title="statement not covered" >if("object"==typeof(t=r[o])&amp;&amp;(a+=e(t)),a==1/0)<span class="cstat-no" title="statement not covered" >return 1/0}</span></span></span>else <span class="cstat-no" title="statement not covered" >for(var n in r){<span class="cstat-no" title="statement not covered" >if("$ref"==n)<span class="cstat-no" title="statement not covered" >return 1/0;<span class="cstat-no" title="statement not covered" >i</span></span>f(f[n])<span class="cstat-no" title="statement not covered" >a++;e</span>lse <span class="cstat-no" title="statement not covered" >if("object"==typeof(t=r[n])&amp;&amp;(a+=e(t)+1),a==1/0)<span class="cstat-no" title="statement not covered" >return 1/0}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span></span>eturn a}</span>(e)&lt;=r:void 0)</span>}function d(e,r){return!1!==r&amp;&amp;(e=y(e)),m(a.parse(e))}function m(e){return a.serialize(e).split("#")[0]+"#"}var v=/#\/?$/;function y(e){return e?e.replace(v,""):""}function g(e,r){return r=y(r),a.resolve(e,r)}},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function e(e,r){for(var t=0;t&lt;r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(r,t,a){return t&amp;&amp;e(r.prototype,t),a&amp;&amp;e(r,a),r}}(),o=t(0);function n(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e instanceof r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span>var s=new WeakMap,i=function(){function e(r){n(this,e),Object.defineProperty(this,"$rxvo",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return r}</span>}),s.set(r,this)}return a(e,[{key:"sendUpdate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >this.$rxvo.getPath(e).model=r}</span>},{key:"sendNext",value:function(e){var r=this;setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"."!==e[0]&amp;&amp;(e="."+e);v</span>ar t=<span class="cstat-no" title="statement not covered" >r.$rxvo.getModelsInPath(e);<span class="cstat-no" title="statement not covered" ></span>""!==t[0]&amp;&amp;t.splice(0,0,""),t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o._oBuilders.get(r.$rxvo).next(e.$ref)}</span>)}</span>,0)}},{key:"sendError",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.$rxvo.getModelsInPath(e).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o._oBuilders.get(t.$rxvo).error(e.$ref,new function <span class="fstat-no" title="function not covered" >e(</span>r,t){<span class="cstat-no" title="statement not covered" >n(this,e),Object.defineProperty(this,"path",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return r}</span>,enumerable:!0}),Object.defineProperty(this,"error",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t}</span>,enumerable:!0})}</span>(e.$ref.path,r))}</span>)}</span>},{key:"sendComplete",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.$rxvo.getModelsInPath(e).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o._oBuilders.get(r.$rxvo).complete(e.$ref)}</span>)}</span>}]),e}(),u=function(){function <span class="fstat-no" title="function not covered" >e(</span>){<span class="cstat-no" title="statement not covered" >n(this,e)}</span>return a(e,null,[{key:"create",value:function(r){return new i(r),e.get(r)}},{key:"get",value:function(e){return s.get(e)}}]),e}();r.default=u},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r.getRoot=r.validate=r.refAtKeyValidation=r.refValidation=r.listDirtyItems=r.makeClean=r.makeDirty=void 0;var a=t(0),o=(r.makeDirty=function(e){a._dirtyModels.get(e.rxvo)[e.path]=!0},r.makeClean=function(e){e.isDirty&amp;&amp;a._dirtyModels.get(e.rxvo)[e.path]&amp;&amp;delete a._dirtyModels.get(e.rxvo)[e.path]},r.listDirtyItems=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.keys(a._dirtyModels.get(e.rxvo))}</span>,r.refValidation=function(e,r){return o(e,"",r)},r.refAtKeyValidation=function(e,r,t){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.isDirty)<span class="cstat-no" title="statement not covered" >return!0;v</span>ar a=""+e.validationPath;r&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r.length&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >a=a+"/"+r)</span>;var o=n(e,a,t);return!0===o||<span class="branch-1 cbranch-no" title="branch not covered" >o}</span>),n=r.validate=function(e,r,t){var o=a._validators.get(e.rxvo),n=o.exec(r,t);return!0===n||(<span class="branch-1 cbranch-no" title="branch not covered" >o.$ajv.errorsText(n.errors)|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >"unknown validation error")</span>};r.getRoot=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.assign({},e.rxvo.model)}</span>},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r.RxVO=void 0;var a,o="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>,</span>n=function(){function e(e,r){for(var t=0;t&lt;r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(r,t,a){return t&amp;&amp;e(r.prototype,t),a&amp;&amp;e(r,a),r}}(),s=t(0),i=t(59),u=t(20),l=t(17),c=t(57),h=t(6),f=(a=h)&amp;&amp;a.__esModule?a:<span class="branch-1 cbranch-no" title="branch not covered" >{default:a};</span>function p(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e instanceof r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span>var d=new WeakMap;r.RxVO=function(){function e(r){var t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>{};p(this,e);var a=t.hasOwnProperty("ajvOptions")?<span class="branch-0 cbranch-no" title="branch not covered" >t.ajvOptions:</span>null,o=new c.AjvWrapper(this,r,a);<span class="missing-if-branch" title="if path not taken" >I</span>if(s._validators.set(this,o),!o.$ajv.validateSchema(r,!1))<span class="cstat-no" title="statement not covered" >throw o.$ajv.errors;O</span>bject.freeze(r),s._schemaSignatures.set(this,r),s._oBuilders.set(this,new i.ObserverBuilder);var h=!1;(r.hasOwnProperty("type")&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"array"===r.type|</span>|r.hasOwnProperty("items")&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >Array.isArray(r.items))</span>&amp;&amp;(<span class="branch-4 cbranch-no" title="branch not covered" >h=!0)</span>,s._dirtyModels.set(this,{}),f.default.create(this);var m=new(h?<span class="branch-0 cbranch-no" title="branch not covered" >l.ItemsModel:</span>u.PropertiesModel)(this);s._oBuilders.get(this).create(m),d.set(this,m);var v=this;!function(){function <span class="fstat-no" title="function not covered" >e(</span>){<span class="cstat-no" title="statement not covered" >p(this,e)}</span>n(e,[{key:"getRef",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >Object.assign({},v.model);<span class="cstat-no" title="statement not covered" ></span>e.split(".").forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r=r[e],console.log(""+r)}</span>)}</span>}])}()}return n(e,[{key:"validate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return s._validators.get(this).exec(e,r)}</span>},{key:"getPath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this.model;<span class="cstat-no" title="statement not covered" ></span>return(e=e.replace(/\/?(properties|items)+\//g,".").replace(/^\./,"")).split(".").forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r[e]&amp;&amp;(r=r[e])}</span>),r}</span>},{key:"getModelsInPath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >[this.model],</span>t=<span class="cstat-no" title="statement not covered" >this.model;<span class="cstat-no" title="statement not covered" ></span>return(e=e.replace(/\/?(properties|items)+\/?/g,".")).split(".").filter(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return t.indexOf(e)&gt;-1}</span>).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t[e]&amp;&amp;(t=t[e],r.push(t))}</span>),r}</span>},{key:"subscribe",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return d.get(this).subscribe(e)}</span>},{key:"subscribeTo",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return d.get(this).subscribeTo(e,r)}</span>},{key:"toString",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return""+this.model.$ref}</span>},{key:"toJSON",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.model.$ref.toJSON()}</span>},{key:"model",get:function(){return d.get(this).model},set:function(e){d.get(this).model=e}},{key:"schema",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s._schemaSignatures.get(this)}</span>},{key:"errors",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s._validators.get(this).$ajv.errors||null}</span>}],[{key:"fromJSON",value:<span class="fstat-no" title="function not covered" >fu</span>nction(r,t){var a=<span class="cstat-no" title="statement not covered" >(void 0===r?"undefined":o(r)).match(/^(string|object)+$/);<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return new e("string"===a[1]?JSON.parse(r):r,t);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("json must be either JSON formatted string or object")}</span>}]),e}()},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a,o=<span class="cstat-no" title="statement not covered" >" ",</span>n=<span class="cstat-no" title="statement not covered" >e.level,</span>s=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>i=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>u=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>l=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>c=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>h=<span class="cstat-no" title="statement not covered" >"data"+(s||""),</span>f=<span class="cstat-no" title="statement not covered" >e.opts.$data&amp;&amp;i&amp;&amp;i.$data;<span class="cstat-no" title="statement not covered" ></span>f?(o+=" var schema"+n+" = "+e.util.getData(i.$data,s,e.dataPathArr)+"; ",a="schema"+n):a=i,o+="if ( ",f&amp;&amp;(o+=" ("+a+" !== undefined &amp;&amp; typeof "+a+" != 'number') || "),o+=" Object.keys("+h+").length "+("maxProperties"==r?"&gt;":"&lt;")+" "+a+") { ";v</span>ar p=<span class="cstat-no" title="statement not covered" >r,</span>d=<span class="cstat-no" title="statement not covered" >d||[];<span class="cstat-no" title="statement not covered" ></span>d.push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(p||"_limitProperties")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { limit: "+a+" } ",!1!==e.opts.messages&amp;&amp;(o+=" , message: 'should NOT have ",o+="maxProperties"==r?"more":"less",o+=" than ",o+=f?"' + "+a+" + '":""+i,o+=" properties' "),e.opts.verbose&amp;&amp;(o+=" , schema:  ",o+=f?"validate.schema"+u:""+i,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),o+=" } "):o+=" {} ";v</span>ar m=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>return o=d.pop(),!e.compositeRule&amp;&amp;c?e.async?o+=" throw new ValidationError(["+m+"]); ":o+=" validate.errors = ["+m+"]; return false; ":o+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&amp;&amp;(o+=" else { "),o}</span>},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a,o=<span class="cstat-no" title="statement not covered" >" ",</span>n=<span class="cstat-no" title="statement not covered" >e.level,</span>s=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>i=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>u=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>l=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>c=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>h=<span class="cstat-no" title="statement not covered" >"data"+(s||""),</span>f=<span class="cstat-no" title="statement not covered" >e.opts.$data&amp;&amp;i&amp;&amp;i.$data;<span class="cstat-no" title="statement not covered" ></span>f?(o+=" var schema"+n+" = "+e.util.getData(i.$data,s,e.dataPathArr)+"; ",a="schema"+n):a=i;v</span>ar p=<span class="cstat-no" title="statement not covered" >"maxLength"==r?"&gt;":"&lt;";<span class="cstat-no" title="statement not covered" ></span>o+="if ( ",f&amp;&amp;(o+=" ("+a+" !== undefined &amp;&amp; typeof "+a+" != 'number') || "),!1===e.opts.unicode?o+=" "+h+".length ":o+=" ucs2length("+h+") ",o+=" "+p+" "+a+") { ";v</span>ar d=<span class="cstat-no" title="statement not covered" >r,</span>m=<span class="cstat-no" title="statement not covered" >m||[];<span class="cstat-no" title="statement not covered" ></span>m.push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(d||"_limitLength")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { limit: "+a+" } ",!1!==e.opts.messages&amp;&amp;(o+=" , message: 'should NOT be ",o+="maxLength"==r?"longer":"shorter",o+=" than ",o+=f?"' + "+a+" + '":""+i,o+=" characters' "),e.opts.verbose&amp;&amp;(o+=" , schema:  ",o+=f?"validate.schema"+u:""+i,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),o+=" } "):o+=" {} ";v</span>ar v=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>return o=m.pop(),!e.compositeRule&amp;&amp;c?e.async?o+=" throw new ValidationError(["+v+"]); ":o+=" validate.errors = ["+v+"]; return false; ":o+=" var err = "+v+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&amp;&amp;(o+=" else { "),o}</span>},function(e,r,t){"use strict";e.exports=function(e,r,t){var a,o=" ",n=e.level,s=e.dataLevel,i=e.schema[r],u=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(s||""),f=e.opts.$data&amp;&amp;i&amp;&amp;i.$data;f?(<span class="branch-0 cbranch-no" title="branch not covered" >o+=" var schema"+n+" = "+e.util.getData(i.$data,s,e.dataPathArr)+"; ",a="schema"+n)</span>:a=i,o+="if ( ",f&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o+=" ("+a+" !== undefined &amp;&amp; typeof "+a+" != 'number') || ")</span>,o+=" "+h+".length "+("maxItems"==r?<span class="branch-0 cbranch-no" title="branch not covered" >"&gt;":</span>"&lt;")+" "+a+") { ";var p=r,d=d||[];d.push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(p||<span class="branch-1 cbranch-no" title="branch not covered" >"_limitItems")</span>+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { limit: "+a+" } ",!1!==e.opts.messages&amp;&amp;(o+=" , message: 'should NOT have ",o+="maxItems"==r?<span class="branch-0 cbranch-no" title="branch not covered" >"more":</span>"less",o+=" than ",o+=f?<span class="branch-0 cbranch-no" title="branch not covered" >"' + "+a+" + '":</span>""+i,o+=" items' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o+=" , schema:  ",o+=f?"validate.schema"+u:""+i,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" ")</span>,o+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >o+=" {} ";</span>var m=o;return o=d.pop(),!e.compositeRule&amp;&amp;c?e.async?<span class="branch-0 cbranch-no" title="branch not covered" >o+=" throw new ValidationError(["+m+"]); ":</span>o+=" validate.errors = ["+m+"]; return false; ":o+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&amp;&amp;(o+=" else { "),o}},function(e,r,t){"use strict";e.exports=function(e,r,t){var a,o=" ",n=e.level,s=e.dataLevel,i=e.schema[r],u=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(s||""),f=e.opts.$data&amp;&amp;i&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >i.$data;</span>f?(<span class="branch-0 cbranch-no" title="branch not covered" >o+=" var schema"+n+" = "+e.util.getData(i.$data,s,e.dataPathArr)+"; ",a="schema"+n)</span>:a=i;var p="maximum"==r,d=p?<span class="branch-0 cbranch-no" title="branch not covered" >"exclusiveMaximum":</span>"exclusiveMinimum",m=e.schema[d],v=e.opts.$data&amp;&amp;m&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >m.$data,</span>y=p?<span class="branch-0 cbranch-no" title="branch not covered" >"&lt;":</span>"&gt;",g=p?<span class="branch-0 cbranch-no" title="branch not covered" >"&gt;":</span>"&lt;",P=void 0;<span class="missing-if-branch" title="if path not taken" >I</span>if(v){var E=<span class="cstat-no" title="statement not covered" >e.util.getData(m.$data,s,e.dataPathArr),</span>b=<span class="cstat-no" title="statement not covered" >"exclusive"+n,</span>w=<span class="cstat-no" title="statement not covered" >"exclType"+n,</span>_=<span class="cstat-no" title="statement not covered" >"exclIsNumber"+n,</span>S=<span class="cstat-no" title="statement not covered" >"' + "+(O="op"+n)+" + '";<span class="cstat-no" title="statement not covered" ></span>o+=" var schemaExcl"+n+" = "+E+"; ",o+=" var "+b+"; var "+w+" = typeof "+(E="schemaExcl"+n)+"; if ("+w+" != 'boolean' &amp;&amp; "+w+" != 'undefined' &amp;&amp; "+w+" != 'number') { ";v</span>ar x;<span class="cstat-no" title="statement not covered" >P=d;<span class="cstat-no" title="statement not covered" >(</span>x=x||[]).push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(P||"_exclusiveLimit")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: {} ",!1!==e.opts.messages&amp;&amp;(o+=" , message: '"+d+" should be boolean' "),e.opts.verbose&amp;&amp;(o+=" , schema: validate.schema"+u+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),o+=" } "):o+=" {} ";v</span>ar R=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>o=x.pop(),!e.compositeRule&amp;&amp;c?e.async?o+=" throw new ValidationError(["+R+"]); ":o+=" validate.errors = ["+R+"]; return false; ":o+=" var err = "+R+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+=" } else if ( ",f&amp;&amp;(o+=" ("+a+" !== undefined &amp;&amp; typeof "+a+" != 'number') || "),o+=" "+w+" == 'number' ? ( ("+b+" = "+a+" === undefined || "+E+" "+y+"= "+a+") ? "+h+" "+g+"= "+E+" : "+h+" "+g+" "+a+" ) : ( ("+b+" = "+E+" === true) ? "+h+" "+g+"= "+a+" : "+h+" "+g+" "+a+" ) || "+h+" !== "+h+") { var op"+n+" = "+b+" ? '"+y+"' : '"+y+"='; ",void 0===i&amp;&amp;(P=d,l=e.errSchemaPath+"/"+d,a=E,f=v)}</span>else{S=y;<span class="missing-if-branch" title="if path not taken" >I</span>if((_="number"==typeof m)&amp;&amp;f){var O=<span class="cstat-no" title="statement not covered" >"'"+S+"'";<span class="cstat-no" title="statement not covered" ></span>o+=" if ( ",f&amp;&amp;(o+=" ("+a+" !== undefined &amp;&amp; typeof "+a+" != 'number') || "),o+=" ( "+a+" === undefined || "+m+" "+y+"= "+a+" ? "+h+" "+g+"= "+m+" : "+h+" "+g+" "+a+" ) || "+h+" !== "+h+") { "}</span>else{_&amp;&amp;void 0===i?(b=!0,P=d,l=e.errSchemaPath+"/"+d,a=m,g+="="):(_&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a=Math[p?"min":"max"](m,i))</span>,m===(!_||<span class="branch-1 cbranch-no" title="branch not covered" >a)</span>?(<span class="branch-0 cbranch-no" title="branch not covered" >b=!0,P=d,l=e.errSchemaPath+"/"+d,g+="=")</span>:(b=!1,S+="="));O="'"+S+"'";o+=" if ( ",f&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o+=" ("+a+" !== undefined &amp;&amp; typeof "+a+" != 'number') || ")</span>,o+=" "+h+" "+g+" "+a+" || "+h+" !== "+h+") { "}}P=P||r,(x=x||[]).push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(P||<span class="branch-1 cbranch-no" title="branch not covered" >"_limit")</span>+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { comparison: "+O+", limit: "+a+", exclusive: "+b+" } ",!1!==e.opts.messages&amp;&amp;(o+=" , message: 'should be "+S+" ",o+=f?<span class="branch-0 cbranch-no" title="branch not covered" >"' + "+a:</span>a+"'"),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o+=" , schema:  ",o+=f?"validate.schema"+u:""+i,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" ")</span>,o+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >o+=" {} ";</span>R=o;return o=x.pop(),!e.compositeRule&amp;&amp;c?e.async?<span class="branch-0 cbranch-no" title="branch not covered" >o+=" throw new ValidationError(["+R+"]); ":</span>o+=" validate.errors = ["+R+"]; return false; ":o+=" var err = "+R+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+=" } ",c&amp;&amp;(o+=" else { "),o}},function(e,r,t){"use strict";e.exports=function(e,r,t){var a="",o=!0===e.schema.$async,n=e.util.schemaHasRulesExcept(e.schema,e.RULES.all,"$ref"),s=e.self._getId(e.schema);if(e.isTop&amp;&amp;(a+=" var validate = ",o&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.async=!0,a+="async ")</span>,a+="function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ",s&amp;&amp;(e.opts.sourceCode||e.opts.processCode)&amp;&amp;(<span class="branch-3 cbranch-no" title="branch not covered" >a+=" /*# sourceURL="+s+" */ ")</span>),"boolean"==typeof e.schema||!n&amp;&amp;!e.schema.$ref){var i=e.level,u=e.dataLevel,l=e.schema["false schema"],c=e.schemaPath+e.util.getProperty("false schema"),h=e.errSchemaPath+"/false schema",f=!e.opts.allErrors,p="data"+(u||""),d="valid"+i;<span class="missing-if-branch" title="if path not taken" >I</span>if(!1===e.schema){<span class="cstat-no" title="statement not covered" >e.isTop?f=!0:a+=" var "+d+" = false; ",(J=J||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'false schema' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(h)+" , params: {} ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'boolean schema is false' "),e.opts.verbose&amp;&amp;(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),a+=" } "):a+=" {} ";v</span>ar m=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>a=J.pop(),!e.compositeRule&amp;&amp;f?e.async?a+=" throw new ValidationError(["+m+"]); ":a+=" validate.errors = ["+m+"]; return false; ":a+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}</span>else e.isTop?a+=o?<span class="branch-0 cbranch-no" title="branch not covered" >" return data; ":</span>" validate.errors = null; return true; ":<span class="branch-1 cbranch-no" title="branch not covered" >a+=" var "+d+" = true; ";</span>return e.isTop&amp;&amp;(a+=" }; return validate; "),a}if(e.isTop){var v=e.isTop;i=e.level=0,u=e.dataLevel=0,p="data";e.rootId=e.resolve.fullPath(e.self._getId(e.root.schema)),e.baseId=e.baseId||e.rootId,delete e.isTop,e.dataPathArr=[void 0],a+=" var vErrors = null; ",a+=" var errors = 0;     ",a+=" if (rootData === undefined) rootData = data; "}else{i=e.level,p="data"+((u=e.dataLevel)||"");<span class="missing-if-branch" title="if path not taken" >I</span>if(s&amp;&amp;(e.baseId=e.resolve.url(e.baseId,s)),o&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >!e.async)<span class="cstat-no" title="statement not covered" ></span>throw new Error("async schema in sync schema");a</span>+=" var errs_"+i+" = errors;"}d="valid"+i,f=!e.opts.allErrors;var y="",g="",P=e.schema.type,E=Array.isArray(P);<span class="missing-if-branch" title="if path not taken" >I</span>if(E&amp;&amp;1==P.length&amp;&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >P=P[0],E=!1)</span>,e.schema.$ref&amp;&amp;n){<span class="cstat-no" title="statement not covered" >if("fail"==e.opts.extendRefs)<span class="cstat-no" title="statement not covered" >throw new Error('$ref: validation keywords used in schema at path "'+e.errSchemaPath+'" (see option extendRefs)');<span class="cstat-no" title="statement not covered" >!</span></span>0!==e.opts.extendRefs&amp;&amp;(n=!1,e.logger.warn('$ref: keywords ignored in schema at path "'+e.errSchemaPath+'"'))}</span>if(e.schema.$comment&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.opts.$comment&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >a+=" "+e.RULES.all.$comment.code(e,"$comment"))</span>,P){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.opts.coerceTypes)var b=<span class="cstat-no" title="statement not covered" >e.util.coerceToTypes(e.opts.coerceTypes,P);</span>var w=e.RULES.types[P];if(b||E||!0===w||w&amp;&amp;!K(w)){c=e.schemaPath+".type",h=e.errSchemaPath+"/type",c=e.schemaPath+".type",h=e.errSchemaPath+"/type";var _=E?"checkDataTypes":"checkDataType";<span class="missing-if-branch" title="if path not taken" >I</span>if(a+=" if ("+e.util[_](P,p,!0)+") { ",b){var S=<span class="cstat-no" title="statement not covered" >"dataType"+i,</span>x=<span class="cstat-no" title="statement not covered" >"coerced"+i;<span class="cstat-no" title="statement not covered" ></span>a+=" var "+S+" = typeof "+p+"; ","array"==e.opts.coerceTypes&amp;&amp;(a+=" if ("+S+" == 'object' &amp;&amp; Array.isArray("+p+")) "+S+" = 'array'; "),a+=" var "+x+" = undefined; ";v</span>ar R=<span class="cstat-no" title="statement not covered" >"",</span>O=<span class="cstat-no" title="statement not covered" >b;<span class="cstat-no" title="statement not covered" ></span>if(O)<span class="cstat-no" title="statement not covered" >for(var j,A=-1,F=O.length-1;A&lt;F;)<span class="cstat-no" title="statement not covered" >j=O[A+=1],A&amp;&amp;(a+=" if ("+x+" === undefined) { ",R+="}"),"array"==e.opts.coerceTypes&amp;&amp;"array"!=j&amp;&amp;(a+=" if ("+S+" == 'array' &amp;&amp; "+p+".length == 1) { "+x+" = "+p+" = "+p+"[0]; "+S+" = typeof "+p+";  } "),"string"==j?a+=" if ("+S+" == 'number' || "+S+" == 'boolean') "+x+" = '' + "+p+"; else if ("+p+" === null) "+x+" = ''; ":"number"==j||"integer"==j?(a+=" if ("+S+" == 'boolean' || "+p+" === null || ("+S+" == 'string' &amp;&amp; "+p+" &amp;&amp; "+p+" == +"+p+" ","integer"==j&amp;&amp;(a+=" &amp;&amp; !("+p+" % 1)"),a+=")) "+x+" = +"+p+"; "):"boolean"==j?a+=" if ("+p+" === 'false' || "+p+" === 0 || "+p+" === null) "+x+" = false; else if ("+p+" === 'true' || "+p+" === 1) "+x+" = true; ":"null"==j?a+=" if ("+p+" === '' || "+p+" === 0 || "+p+" === false) "+x+" = null; ":"array"==e.opts.coerceTypes&amp;&amp;"array"==j&amp;&amp;(a+=" if ("+S+" == 'string' || "+S+" == 'number' || "+S+" == 'boolean' || "+p+" == null) "+x+" = ["+p+"]; ");<span class="cstat-no" title="statement not covered" >a</span></span></span>+=" "+R+" if ("+x+" === undefined) {   ",(J=J||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'type' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(h)+" , params: { type: '",a+=E?""+P.join(","):""+P,a+="' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should be ",a+=E?""+P.join(","):""+P,a+="' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+c+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),a+=" } "):a+=" {} ";<span class="cstat-no" title="statement not covered" >m</span>=a;<span class="cstat-no" title="statement not covered" >a</span>=J.pop(),!e.compositeRule&amp;&amp;f?e.async?a+=" throw new ValidationError(["+m+"]); ":a+=" validate.errors = ["+m+"]; return false; ":a+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else {  ";v</span>ar D=<span class="cstat-no" title="statement not covered" >u?"data"+(u-1||""):"parentData";<span class="cstat-no" title="statement not covered" ></span>a+=" "+p+" = "+x+"; ",u||(a+="if ("+D+" !== undefined)"),a+=" "+D+"["+(u?e.dataPathArr[u]:"parentDataProperty")+"] = "+x+"; } "}</span>else{(J=J||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'type' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(h)+" , params: { type: '",a+=E?""+P.join(","):""+P,a+="' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should be ",a+=E?""+P.join(","):""+P,a+="' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" , schema: validate.schema"+c+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" ")</span>,a+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >a+=" {} ";</span>m=a;a=J.pop(),!e.compositeRule&amp;&amp;f?e.async?<span class="branch-0 cbranch-no" title="branch not covered" >a+=" throw new ValidationError(["+m+"]); ":</span>a+=" validate.errors = ["+m+"]; return false; ":a+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}a+=" } "}}if(e.schema.$ref&amp;&amp;!n)a+=" "+e.RULES.all.$ref.code(e,"$ref")+" ",f&amp;&amp;(a+=" } if (errors === ",a+=v?<span class="branch-0 cbranch-no" title="branch not covered" >"0":</span>"errs_"+i,a+=") { ",g+="}");else{var $=e.RULES;<span class="missing-if-branch" title="else path not taken" >E</span>if($)for(var k=-1,I=$.length-1;k&lt;I;)if(K(w=$[k+=1])){<span class="missing-if-branch" title="if path not taken" >I</span>if(w.type&amp;&amp;(a+=" if ("+e.util.checkDataType(w.type,p)+") { "),e.opts.useDefaults&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >!e.compositeRule)<span class="cstat-no" title="statement not covered" ></span>if("object"==w.type&amp;&amp;e.schema.properties){<span class="cstat-no" title="statement not covered" >l=e.schema.properties;v</span>ar C=<span class="cstat-no" title="statement not covered" >Object.keys(l);<span class="cstat-no" title="statement not covered" ></span>if(C)<span class="cstat-no" title="statement not covered" >for(var T,M=-1,U=C.length-1;M&lt;U;){<span class="cstat-no" title="statement not covered" >if(void 0!==(z=l[T=C[M+=1]]).default)<span class="cstat-no" title="statement not covered" >a+="  if ("+(B=p+e.util.getProperty(T))+" === undefined) "+B+" = ","shared"==e.opts.useDefaults?a+=" "+e.useDefault(z.default)+" ":a+=" "+JSON.stringify(z.default)+" ",a+="; "}</span></span>}</span></span>else <span class="cstat-no" title="statement not covered" >if("array"==w.type&amp;&amp;Array.isArray(e.schema.items)){var N=<span class="cstat-no" title="statement not covered" >e.schema.items;<span class="cstat-no" title="statement not covered" ></span>if(N){<span class="cstat-no" title="statement not covered" >A=-1;<span class="cstat-no" title="statement not covered" >f</span>or(var z,L=N.length-1;A&lt;L;){var B;<span class="cstat-no" title="statement not covered" >if(void 0!==(z=N[A+=1]).default)<span class="cstat-no" title="statement not covered" >a+="  if ("+(B=p+"["+A+"]")+" === undefined) "+B+" = ","shared"==e.opts.useDefaults?a+=" "+e.useDefault(z.default)+" ":a+=" "+JSON.stringify(z.default)+" ",a+="; "}</span></span>}</span>}</span>v</span></span>ar V=w.rules;<span class="missing-if-branch" title="else path not taken" >E</span>if(V)for(var Q,q=-1,H=V.length-1;q&lt;H;)if(W(Q=V[q+=1])){var Y=Q.code(e,Q.keyword,w.type);Y&amp;&amp;(a+=" "+Y+" ",f&amp;&amp;(y+="}"))}if(f&amp;&amp;(a+=" "+y+" ",y=""),w.type&amp;&amp;(a+=" } ",P&amp;&amp;P===w.type&amp;&amp;!b)){a+=" else { ";var J;c=e.schemaPath+".type",h=e.errSchemaPath+"/type";(J=J||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'type' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(h)+" , params: { type: '",a+=E?<span class="branch-0 cbranch-no" title="branch not covered" >""+P.join(","):</span>""+P,a+="' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should be ",a+=E?<span class="branch-0 cbranch-no" title="branch not covered" >""+P.join(","):</span>""+P,a+="' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" , schema: validate.schema"+c+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" ")</span>,a+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >a+=" {} ";</span>m=a;a=J.pop(),!e.compositeRule&amp;&amp;f?e.async?<span class="branch-0 cbranch-no" title="branch not covered" >a+=" throw new ValidationError(["+m+"]); ":</span>a+=" validate.errors = ["+m+"]; return false; ":a+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } "}f&amp;&amp;(a+=" if (errors === ",a+=v?"0":"errs_"+i,a+=") { ",g+="}")}}function K(e){for(var r=e.rules,t=0;t&lt;r.length;t++)if(W(r[t]))return!0}function W(r){return void 0!==e.schema[r.keyword]||r.implements&amp;&amp;function(r){for(var t=r.implements,a=0;a&lt;t.length;a++)if(void 0!==e.schema[t[a]])return!0}(r)}return f&amp;&amp;(a+=" "+g+" "),v?(o?(<span class="branch-0 cbranch-no" title="branch not covered" >a+=" if (errors === 0) return data;           ",a+=" else throw new ValidationError(vErrors); ")</span>:(a+=" validate.errors = vErrors; ",a+=" return errors === 0;       "),a+=" }; return validate;"):a+=" var "+d+" = errors === errs_"+i+";",a=e.util.cleanUpCode(a),v&amp;&amp;(a=e.util.finalCleanUpCode(a,o)),a}},function(e,r,t){"use strict";e.exports=function(e,r){r||(r={}),"function"==typeof r&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >r={cmp:r})</span>;var t,a="boolean"==typeof r.cycles&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r.cycles,</span>o=r.cmp&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t=r.cmp,<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(r,a){var o=<span class="cstat-no" title="statement not covered" >{key:r,value:e[r]},</span>n=<span class="cstat-no" title="statement not covered" >{key:a,value:e[a]};<span class="cstat-no" title="statement not covered" ></span>return t(o,n)}</span>}</span>)</span>,n=[];return function e(r){<span class="missing-if-branch" title="else path not taken" >E</span>if(r&amp;&amp;r.toJSON&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >"function"==typeof r.toJSON&amp;</span>&amp;(<span class="branch-3 cbranch-no" title="branch not covered" >r=r.toJSON())</span>,void 0!==r){if("number"==typeof r)return isFinite(r)?""+r:<span class="branch-1 cbranch-no" title="branch not covered" >"null";</span>if("object"!=typeof r)return JSON.stringify(r);var t,s;if(Array.isArray(r)){for(s="[",t=0;t&lt;r.length;t++)t&amp;&amp;(s+=","),s+=e(r[t])||<span class="branch-1 cbranch-no" title="branch not covered" >"null";</span>return s+"]"}<span class="missing-if-branch" title="if path not taken" >I</span>if(null===r)<span class="cstat-no" title="statement not covered" >return"null";<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(-1!==n.indexOf(r)){<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >return JSON.stringify("__cycle__");<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError("Converting circular structure to JSON")}</span>var i=n.push(r)-1,u=Object.keys(r).sort(o&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >o(r))</span>;for(s="",t=0;t&lt;u.length;t++){var l=u[t],c=e(r[l]);c&amp;&amp;(s&amp;&amp;(s+=","),s+=JSON.stringify(l)+":"+c)}return n.splice(i,1),"{"+s+"}"}}(e)}},function(e,r,t){"use strict";var a=t(2);e.exports=function(e){a.copy(e,this)}},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r.Model=void 0;var a=function(){function e(e,r){for(var t=0;t&lt;r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(r,t,a){return t&amp;&amp;e(r.prototype,t),a&amp;&amp;e(r,a),r}}(),o="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>,</span>n=t(0),s=t(8),i=t(18),u=t(7);function l(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e instanceof r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span>var c=function(e,r){var t=void 0;<span class="missing-if-branch" title="else path not taken" >E</span>if(r instanceof s.RxVO)t=new i.MetaData(e,{_path:"",_parent:null,_root:e,_rxvo:r});else{<span class="cstat-no" title="statement not covered" >if("object"!==(void 0===r?"undefined":o(r)))<span class="cstat-no" title="statement not covered" >throw"Invalid attempt to construct Model.tip: use `new RxVO([schema])` instead";<span class="cstat-no" title="statement not covered" >t</span></span>=r instanceof i.MetaData?r:new i.MetaData(void 0,r)}</span>n._mdRef.set(e,t)};r.Model=function(){function e(){l(this,e),this instanceof i.MetaData||c(this,arguments[0])}return a(e,[{key:"subscribe",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.subscribeTo(this.path,e)}</span>},{key:"subscribeTo",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var t=<span class="cstat-no" title="statement not covered" >n._oBuilders.get(this.rxvo).getObserverForPath(e);<span class="cstat-no" title="statement not covered" ></span>if(null===t)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>[{call:"onNext",func:"next"},{call:"onError",func:"error"},{call:"onComplete",func:"complete"}].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.hasOwnProperty(e.func)&amp;&amp;a.push(t[e.call].subscribe({next:r[e.func]}))}</span>);v</span>ar o=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >e(</span>){<span class="cstat-no" title="statement not covered" >l(this,e)}</span>;<span class="cstat-no" title="statement not covered" ></span>return o.prototype.unsubscribe=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.unsubscribe()}</span>)}</span>,new o}</span>},{key:"validate",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return(0,u.validate)(this,this.validationPath,e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return!0}</span>}</span>},{key:"reset",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var r=<span class="cstat-no" title="statement not covered" >Array.isArray(this.model),</span>t=<span class="cstat-no" title="statement not covered" >r?[]:{},</span>a=<span class="cstat-no" title="statement not covered" >this.validate(t);<span class="cstat-no" title="statement not covered" ></span>if(!0!==a)<span class="cstat-no" title="statement not covered" >return n._oBuilders.get(this.rxvo).error(this,a),this;<span class="cstat-no" title="statement not covered" >(</span></span>0,u.makeDirty)(this);v</span>ar o=<span class="cstat-no" title="statement not covered" >r?this.model:Object.keys(this.model);<span class="cstat-no" title="statement not covered" ></span>o.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >Object.isFrozen(e)||e.freeze()}</span>(r?e:o[e])}</span>);v</span>ar s=<span class="cstat-no" title="statement not covered" >new Proxy(e.createRef(this,t),this.handler);<span class="cstat-no" title="statement not covered" ></span>return n._object.set(this,s),(0,u.makeClean)(this),n._oBuilders.get(this.rxvo).next(this),this}</span>},{key:"valueOf",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n._object.get(this)}</span>},{key:"toJSON",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return function <span class="fstat-no" title="function not covered" >r(</span>t){<span class="cstat-no" title="statement not covered" >if(t.hasOwnProperty("toJSON")&amp;&amp;"function"==typeof e.toJSON)<span class="cstat-no" title="statement not covered" >return t.toJSON();<span class="cstat-no" title="statement not covered" >i</span></span>f("object"===(void 0===t?"undefined":o(t))){var a=<span class="cstat-no" title="statement not covered" >Array.isArray(t)?[]:{};<span class="cstat-no" title="statement not covered" ></span>for(var n in t)<span class="cstat-no" title="statement not covered" >t.hasOwnProperty(n)&amp;&amp;(a[n]=r(t[n]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>(this.valueOf())}</span>},{key:"toString",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]&amp;&amp;arguments[0];<span class="cstat-no" title="statement not covered" ></span>return console.log(this.toJSON()),JSON.stringify(this.toJSON(),null,e?2:void 0)}</span>},{key:"freeze",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Object.freeze(n._object.get(this)),n._oBuilders.get(this.rxvo).complete(this),this}</span>},{key:"handler",get:function(){return{setPrototypeOf:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>,isExtensible:function(e){return Object.isExtensible(e)},preventExtensions:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.preventExtensions(e)}</span>,getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(e,r)}</span>,defineProperty:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return Object.defineProperty(e,r,t)}</span>,has:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r in e}</span>,ownKeys:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Reflect.ownKeys(e)}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>}}},{key:"model",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return null}</span>},{key:"objectID",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n._mdRef.get(this)._id}</span>},{key:"root",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n._mdRef.get(this).root||this}</span>},{key:"path",get:function(){return n._mdRef.get(this).path||""}},{key:"jsonPath",get:function(){return this.path.replace(/\/?(properties|items)+\/?/g,".").replace(/^\./,"")}},{key:"parent",get:function(){return n._mdRef.get(this).parent||null}},{key:"isDirty",get:function(){return n._dirtyModels.get(this.rxvo)[this.path]||!1||null!==this.parent&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >this.parent.isDirty}</span>},{key:"rxvo",get:function(){return n._mdRef.get(this).rxvo}},{key:"options",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n._schemaOptions.get(this)}</span>},{key:"isFrozen",get:function(){var e=Object.isFrozen(n._object.get(this));return e||null!==this.parent&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >this.parent.isFrozen}</span>},{key:"validationPath",get:function(){return""===this.path?"root#/":<span class="branch-1 cbranch-no" title="branch not covered" >"root#"+this.path}</span>},{key:"schema",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>},{key:"signature",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.schema}</span>}],[{key:"createRef",value:function(e,r){return Object.defineProperty(r,"$ref",{value:e,writable:!1}),r}}]),e}()},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r.ItemsModel=void 0;var a,o="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>,</span>n=function(){function e(e,r){for(var t=0;t&lt;r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a.writable=!0)</span>,Object.defineProperty(e,a.key,a)}}return function(r,t,a){return t&amp;&amp;e(r.prototype,t),a&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e(r,a),</span>r}}(),s=t(0),i=t(16),u=t(19),l=t(7),c=t(6),h=(a=c)&amp;&amp;a.__esModule?a:<span class="branch-1 cbranch-no" title="branch not covered" >{default:a};</span>var f=new WeakMap;r.ItemsModel=function(e){function <span class="fstat-no" title="function not covered" >r(</span>){<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(!(e instanceof r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span></span>(this,r);v</span>ar e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new ReferenceError("this hasn't been initialised - super() hasn't been called");<span class="cstat-no" title="statement not covered" >r</span></span>eturn!r||"object"!=typeof r&amp;&amp;"function"!=typeof r?e:r}</span>(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,arguments[0]));<span class="cstat-no" title="statement not covered" ></span>return s._schemaHelpers.set(e,new u.SchemaHelpers(e)),s._object.set(e,new Proxy(i.Model.createRef(e,[]),e.handler)),e}</span>return function(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if("function"!=typeof r&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >null!==r)<span class="cstat-no" title="statement not covered" ></span>throw new TypeError("Super expression must either be null or a function, not "+typeof r);e</span>.prototype=Object.create(r&amp;&amp;r.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),r&amp;&amp;(Object.setPrototypeOf?Object.setPrototypeOf(e,r):<span class="branch-1 cbranch-no" title="branch not covered" >e.__proto__=r)</span>}(r,i.Model),n(r,[{key:"model",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s._object.get(this)}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!Array.isArray(e)||this.isFrozen)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!0!==(0,l.refValidation)(this,e))<span class="cstat-no" title="statement not covered" >return h.default.get(this.rxvo).sendError(this.jsonPath,this.rxvo.errors),!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.isDirty||(0,l.makeDirty)(this),s._object.set(this,new Proxy(i.Model.createRef(this,[]),this.handler)),f.set(this,!0);<span class="cstat-no" title="statement not covered" >t</span>ry{var t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>e.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s._object.get(r)[t++]=e}</span>)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return(0,l.makeClean)(this),console.log(e),h.default.get(this.rxvo).sendError.bind(this)(this.jsonPath,e),!1}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn(0,l.makeClean)(this),h.default.get(this.rxvo).sendNext(this.jsonPath),f.delete(this),!0}</span>},{key:"handler",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return Object.assign(function <span class="fstat-no" title="function not covered" >e(</span>r,t,a){<span class="cstat-no" title="statement not covered" >null===r&amp;&amp;(r=Function.prototype);v</span>ar o=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor(r,t);<span class="cstat-no" title="statement not covered" ></span>if(void 0===o){var n=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf(r);<span class="cstat-no" title="statement not covered" ></span>return null===n?void 0:e(n,t,a)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("value"in o)<span class="cstat-no" title="statement not covered" >return o.value;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >o.get;<span class="cstat-no" title="statement not covered" ></span>return void 0!==s?s.call(a):void 0}</span>(r.prototype.__proto__||Object.getPrototypeOf(r.prototype),"handler",this),{get:<span class="fstat-no" title="function not covered" >fu</span>nction(r,t){<span class="cstat-no" title="statement not covered" >if("length"===t)<span class="cstat-no" title="statement not covered" >return r.length;<span class="cstat-no" title="statement not covered" >i</span></span>f(t in Array.prototype){var a=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return["fill","pop","push","shift","splice","unshift"].indexOf(t)&gt;-1?<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var o=arguments.length,n=Array(o),s=0;s&lt;o;s++)<span class="cstat-no" title="statement not covered" >n[s]=arguments[s];v</span></span>ar i=<span class="cstat-no" title="statement not covered" >[].concat(r),</span>u=<span class="cstat-no" title="statement not covered" >r[t].apply(i,n);<span class="cstat-no" title="statement not covered" ></span>return!0!==(0,l.refValidation)(a,i)?((0,l.makeClean)(a),h.default.get(e.rxvo).sendError(a.jsonPath,a.rxvo.errors),!1):(null!==e.parent?e.parent.model[e.jsonPath.split(".").pop()]=i:e.rxvo.model=i,u)}</span>:r[t]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn"$ref"===t?e:r[t]}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(r,t,a){<span class="cstat-no" title="statement not covered" >if(t in Array.prototype)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.isFrozen)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >f.get(e);<span class="cstat-no" title="statement not covered" ></span>if(!0!==(0,l.refAtKeyValidation)(e,"items",a))<span class="cstat-no" title="statement not covered" >return void 0!==n&amp;&amp;((0,l.makeClean)(e),h.default.get(e.rxvo).sendError(e.jsonPath,e.rxvo.errors)),!1;<span class="cstat-no" title="statement not covered" >"</span></span>object"===(void 0===a?"undefined":o(a))&amp;&amp;(a=s._schemaHelpers.get(e).setChildObject(""+e.path,a));<span class="cstat-no" title="statement not covered" >r</span>eturn r[t]=a,void 0!==n&amp;&amp;((0,l.makeClean)(e),h.default.get(e.rxvo).sendNext(e.jsonPath)),!0}</span>,deleteProperty:<span class="fstat-no" title="function not covered" >fu</span>nction(r,t){var a=<span class="cstat-no" title="statement not covered" >f.get(e),</span>o=<span class="cstat-no" title="statement not covered" >[].concat(r);<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >o.splice(t,1)}</span>catch(r){<span class="cstat-no" title="statement not covered" >return a||((0,l.makeClean)(e),h.default.get(e.rxvo).sendError(e.jsonPath,r)),!1}</span>v</span>ar n=<span class="cstat-no" title="statement not covered" >(0,l.refValidation)(e,o);<span class="cstat-no" title="statement not covered" ></span>return!0!==n?(a||((0,l.makeClean)(e),h.default.get(e.rxvo).sendError(e.jsonPath,n)),!1):(r.splice(t,1),(0,l.makeClean)(e),h.default.get(e.rxvo).sendNext(e.jsonPath),!0)}</span>})}</span>}]),r}()},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r.MetaData=void 0;var a=function(){function e(e,r){for(var t=0;t&lt;r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(r,t,a){return t&amp;&amp;e(r.prototype,t),a&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e(r,a),</span>r}}(),o=t(0);var n=new WeakMap;r.MetaData=function(){function e(r){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >{};</span>!function(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e instanceof r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span>(this,e);var a=o.wf.Fun.getConstructorName(r);<span class="missing-if-branch" title="else path not taken" >E</span>if(null==this._createID){var s=0;e.prototype._createID=function(){return null==this.__objID&amp;&amp;(s+=1,this.__objID=""+a+s),this.__objID}}t=Object.assign({},t,{_id:this._createID(),_className:a,_created:Date.now()}),n.set(this,t),o._mdRef.set(this,this)}return a(e,[{key:"get",value:function(e){var r=n.get(this);return r.hasOwnProperty(e)?r[e]:<span class="branch-1 cbranch-no" title="branch not covered" >null}</span>},{key:"set",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>},{key:"toString",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return JSON.stringify(n.get(this))}</span>},{key:"objectID",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.get("_id")}</span>},{key:"root",get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.get("_root")}</span>},{key:"path",get:function(){return this.get("_path")}},{key:"rxvo",get:function(){return this.get("_rxvo")}},{key:"parent",get:function(){return this.get("_parent")}}]),e}()},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r.SchemaHelpers=void 0;var a="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?function(e){return typeof e}:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>,</span>o=function(){function e(e,r){for(var t=0;t&lt;r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(r,t,a){return t&amp;&amp;e(r.prototype,t),a&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e(r,a),</span>r}}(),n=t(0),s=t(18),i=t(20),u=t(17);r.SchemaHelpers=function(){function e(r){<span class="missing-if-branch" title="if path not taken" >I</span>if(function(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e instanceof r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span>(this,e),!(0,n._exists)(r)||"object"!==(void 0===r?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>a(r)))<span class="cstat-no" title="statement not covered" >throw new Error("arguments[0] must be an object");t</span>his._ref=r,Object.seal(this)}return o(e,[{key:"setObject",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return"string"==typeof e?e:(Object.keys(e).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var a=<span class="cstat-no" title="statement not covered" >r._ref.set(t,e[t]);<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof a)<span class="cstat-no" title="statement not covered" >throw new Error(a)}</span></span>),this._ref)}</span>},{key:"setChildObject",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var t=<span class="cstat-no" title="statement not covered" >n._mdRef.get(this._ref),</span>o=<span class="cstat-no" title="statement not covered" >this.createSchemaChild(e,r,t);<span class="cstat-no" title="statement not covered" ></span>return n._oBuilders.get(this._ref.rxvo).create(o),"string"==typeof o?o:(0,n._exists)(o)&amp;&amp;"object"===(void 0===o?"undefined":a(o))?(o.model=r,o.model):"'"+e+"' was invalid"}</span>},{key:"createSchemaChild",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >Array.isArray(this._ref.model)?this._ref.path+"/items":this._ref.path+"/properties/"+e,</span>o=<span class="cstat-no" title="statement not covered" >Object.assign({_path:a,_parent:this._ref,_root:this._ref.root,_rxvo:this._ref.rxvo},t||{}),</span>n=<span class="cstat-no" title="statement not covered" >new s.MetaData(this._ref,o);<span class="cstat-no" title="statement not covered" ></span>return new(Array.isArray(r)?u.ItemsModel:i.PropertiesModel)(n)}</span>}]),e}()},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r.PropertiesModel=void 0;var a,o="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?function(e){return typeof e}:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>,</span>n=function(){function e(e,r){for(var t=0;t&lt;r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(r,t,a){return t&amp;&amp;e(r.prototype,t),a&amp;&amp;e(r,a),r}}(),s=t(0),i=t(7),u=t(19),l=t(16),c=t(6),h=(a=c)&amp;&amp;a.__esModule?a:<span class="branch-1 cbranch-no" title="branch not covered" >{default:a};</span>r.PropertiesModel=function(e){function r(){!function(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e instanceof r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span>(this,r);var e=function(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!e)<span class="cstat-no" title="statement not covered" >throw new ReferenceError("this hasn't been initialised - super() hasn't been called");r</span>eturn!r||<span class="branch-1 cbranch-no" title="branch not covered" >"object"!=typeof r&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >"function"!=typeof r?</span>e:<span class="branch-1 cbranch-no" title="branch not covered" >r}</span>(this,(r.__proto__||<span class="branch-1 cbranch-no" title="branch not covered" >Object.getPrototypeOf(r))</span>.call(this,arguments[0]));return s._schemaHelpers.set(e,new u.SchemaHelpers(e)),s._object.set(e,new Proxy(l.Model.createRef(e,{}),e.handler)),e}return function(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if("function"!=typeof r&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >null!==r)<span class="cstat-no" title="statement not covered" ></span>throw new TypeError("Super expression must either be null or a function, not "+typeof r);e</span>.prototype=Object.create(r&amp;&amp;r.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),r&amp;&amp;(Object.setPrototypeOf?Object.setPrototypeOf(e,r):<span class="branch-1 cbranch-no" title="branch not covered" >e.__proto__=r)</span>}(r,l.Model),n(r,[{key:"get",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.model[e]}</span>},{key:"set",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return!!(0,i.refAtKeyValidation)(this,e,r)&amp;&amp;(this.isDirty||(0,i.makeDirty)(this),this.model[e]=r,h.default.get(this.rxvo).sendNext(this.jsonPath),(0,i.makeClean)(this),this)}</span>},{key:"handler",get:function(){var e=this,t=this;return Object.assign(function e(r,t,a){null===r&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >r=Function.prototype)</span>;var o=Object.getOwnPropertyDescriptor(r,t);<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0===o){var n=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf(r);<span class="cstat-no" title="statement not covered" ></span>return null===n?void 0:e(n,t,a)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if("value"in o)<span class="cstat-no" title="statement not covered" >return o.value;v</span>ar s=o.get;return void 0!==s?s.call(a):<span class="branch-1 cbranch-no" title="branch not covered" >void 0}</span>(r.prototype.__proto__||<span class="branch-1 cbranch-no" title="branch not covered" >Object.getPrototypeOf(r.prototype),</span>"handler",this),{get:function(r,t){return"$ref"===t?<span class="branch-0 cbranch-no" title="branch not covered" >e:</span>r[t]},set:function(r,a,n){var u=s._schemaHelpers.get(e);<span class="missing-if-branch" title="if path not taken" >I</span>if(a in Object.prototype)<span class="cstat-no" title="statement not covered" >return!0;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e.isFrozen)<span class="cstat-no" title="statement not covered" >return!1;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!e.isDirty){var l=<span class="cstat-no" title="statement not covered" >Object.assign({},r);<span class="cstat-no" title="statement not covered" ></span>if(l[a]=n,!0!==(0,i.refValidation)(e,l))<span class="cstat-no" title="statement not covered" >return(0,i.makeClean)(e),s._oBuilders.get(e.rxvo).error(t,e.rxvo.errors),!1}<span class="missing-if-branch" title="if path not taken" >I</span></span></span>if("object"===(void 0===a?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>o(a))){var c=<span class="cstat-no" title="statement not covered" >u.setObject(a);<span class="cstat-no" title="statement not covered" ></span>return"string"!=typeof c||((0,i.makeClean)(e),s._oBuilders.get(e.rxvo).error(t,c),!1)}</span>return"object"===(void 0===n?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>o(n))&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"string"==typeof(n=u.setChildObject(a,n))?</span>(<span class="branch-0 cbranch-no" title="branch not covered" >(0,i.makeClean)(e),s._oBuilders.get(e.rxvo).error(t,n),!1)</span>:(r[a]=n,!0)},deleteProperty:<span class="fstat-no" title="function not covered" >fu</span>nction(r,t){var a=<span class="cstat-no" title="statement not covered" >Object.assign({},e.model);<span class="cstat-no" title="statement not covered" ></span>return delete a[t],!!e.validate(a)&amp;&amp;(delete r[t],!0)}</span>})}},{key:"model",get:function(){return s._object.get(this)},set:function(e){var r=this;return"object"===(void 0===e?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>o(e))&amp;&amp;!this.isFrozen&amp;&amp;(!0!==(0,i.refValidation)(this,e)?(<span class="branch-0 cbranch-no" title="branch not covered" >h.default.get(this.rxvo).sendError(this.jsonPath,this.rxvo.errors),!1)</span>:(this.isDirty||(0,i.makeDirty)(this),s._object.set(this,new Proxy(l.Model.createRef(this,{}),this.handler)),Object.keys(e).forEach(function(t){try{r.model[t]=e[t]}catch(e){<span class="cstat-no" title="statement not covered" >return(0,i.makeClean)(r),h.default.get(r.rxvo).sendError(r.jsonPath,e),!1}</span>}),(0,i.makeClean)(this),this.isDirty||h.default.get(this.rxvo).sendNext(this.jsonPath),!0))}}],[{key:"concatPathAddr",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return e.length?e+"/"+r:""+r}</span>}]),r}()},function(e,r,t){"use strict";function a(...e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.length&gt;1){e[0]=e[0].slice(0,-1);const r=e.length-1;for(let t=1;t&lt;r;++t)e[t]=e[t].slice(1,-1);return e[r]=e[r].slice(1),e.join("")}<span class="cstat-no" title="statement not covered" >return e[0]}</span>function o(e){return"(?:"+e+")"}function <span class="fstat-no" title="function not covered" >n(</span>e){<span class="cstat-no" title="statement not covered" >return void 0===e?"undefined":null===e?"null":Object.prototype.toString.call(e).split(" ").pop().split("]").shift().toLowerCase()}</span>function <span class="fstat-no" title="function not covered" >s(</span>e){<span class="cstat-no" title="statement not covered" >return e.toUpperCase()}</span>function i(e){const r=a("[0-9]","[A-Fa-f]"),t=o(o("%[EFef]"+r+"%"+r+r+"%"+r+r)+"|"+o("%[89A-Fa-f]"+r+"%"+r+r)+"|"+o("%"+r+r)),n="[\\!\\$\\&amp;\\'\\(\\)\\*\\+\\,\\;\\=]",s=a("[\\:\\/\\?\\#\\[\\]\\@]",n),i=e?"[\\uE000-\\uF8FF]":"[]",u=a("[A-Za-z]","[0-9]","[\\-\\.\\_\\~]",e?"[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]":"[]"),l=o("[A-Za-z]"+a("[A-Za-z]","[0-9]","[\\+\\-\\.]")+"*"),c=o(o(t+"|"+a(u,n,"[\\:]"))+"*"),h=o(o("25[0-5]")+"|"+o("2[0-4][0-9]")+"|"+o("1[0-9][0-9]")+"|"+o("[1-9][0-9]")+"|[0-9]"),f=o(h+"\\."+h+"\\."+h+"\\."+h),p=o(r+"{1,4}"),d=o(o(p+"\\:"+p)+"|"+f),m=o([o(o(p+"\\:")+"{6}"+d),o("\\:\\:"+o(p+"\\:")+"{5}"+d),o(o(p)+"?\\:\\:"+o(p+"\\:")+"{4}"+d),o(o(o(p+"\\:")+"{0,1}"+p)+"?\\:\\:"+o(p+"\\:")+"{3}"+d),o(o(o(p+"\\:")+"{0,2}"+p)+"?\\:\\:"+o(p+"\\:")+"{2}"+d),o(o(o(p+"\\:")+"{0,3}"+p)+"?\\:\\:"+p+"\\:"+d),o(o(o(p+"\\:")+"{0,4}"+p)+"?\\:\\:"+d),o(o(o(p+"\\:")+"{0,5}"+p)+"?\\:\\:"+p),o(o(o(p+"\\:")+"{0,6}"+p)+"?\\:\\:")].join("|")),v=o("\\["+o(m+"|"+o("[vV]"+r+"+\\."+a(u,n,"[\\:]")+"+"))+"\\]"),y=o(o(t+"|"+a(u,n))+"*"),g=o(v+"|"+f+"(?!"+y+")|"+y),P=o("[0-9]*"),E=o(o(c+"@")+"?"+g+o("\\:"+P)+"?"),b=o(t+"|"+a(u,n,"[\\:\\@]")),w=o(b+"*"),_=o(b+"+"),S=o(o(t+"|"+a(u,n,"[\\@]"))+"+"),x=o(o("\\/"+w)+"*"),R=o("\\/"+o(_+x)+"?"),O=o(S+x),j=o(_+x),A="(?!"+b+")",F=(o(x+"|"+R+"|"+O+"|"+j+"|"+A),o(o(b+"|"+a("[\\/\\?]",i))+"*")),D=o(o(b+"|[\\/\\?]")+"*"),$=o(o("\\/\\/"+E+x)+"|"+R+"|"+j+"|"+A);o(o(l+"\\:"+$+o("\\?"+F)+"?"+o("\\#"+D)+"?")+"|"+o(o(o("\\/\\/"+E+x)+"|"+R+"|"+O+"|"+A)+o("\\?"+F)+"?"+o("\\#"+D)+"?")),o(l+"\\:"+$+o("\\?"+F)+"?"),o(o("\\/\\/("+o("("+c+")@")+"?("+g+")"+o("\\:("+P+")")+"?)")+"?("+x+"|"+R+"|"+j+"|"+A+")"),o("\\?("+F+")"),o("\\#("+D+")"),o(o("\\/\\/("+o("("+c+")@")+"?("+g+")"+o("\\:("+P+")")+"?)")+"?("+x+"|"+R+"|"+O+"|"+A+")"),o("\\?("+F+")"),o("\\#("+D+")"),o(o("\\/\\/("+o("("+c+")@")+"?("+g+")"+o("\\:("+P+")")+"?)")+"?("+x+"|"+R+"|"+j+"|"+A+")"),o("\\?("+F+")"),o("\\#("+D+")"),o("("+c+")@"),o("\\:("+P+")");return{NOT_SCHEME:new RegExp(a("[^]","[A-Za-z]","[0-9]","[\\+\\-\\.]"),"g"),NOT_USERINFO:new RegExp(a("[^\\%\\:]",u,n),"g"),NOT_HOST:new RegExp(a("[^\\%\\[\\]\\:]",u,n),"g"),NOT_PATH:new RegExp(a("[^\\%\\/\\:\\@]",u,n),"g"),NOT_PATH_NOSCHEME:new RegExp(a("[^\\%\\/\\@]",u,n),"g"),NOT_QUERY:new RegExp(a("[^\\%]",u,n,"[\\:\\@\\/\\?]",i),"g"),NOT_FRAGMENT:new RegExp(a("[^\\%]",u,n,"[\\:\\@\\/\\?]"),"g"),ESCAPE:new RegExp(a("[^]",u,n),"g"),UNRESERVED:new RegExp(u,"g"),OTHER_CHARS:new RegExp(a("[^\\%]",u,s),"g"),PCT_ENCODED:new RegExp(t,"g"),IPV6ADDRESS:new RegExp("\\[?("+m+")\\]?","g")}}t.r(r);var u=i(!1),l=i(!0),c=t(1),h=t.n(c);const f={};function <span class="fstat-no" title="function not covered" >p(</span>e){const r=<span class="cstat-no" title="statement not covered" >e.charCodeAt(0);</span>let t;<span class="cstat-no" title="statement not covered" >return t=r&lt;16?"%0"+r.toString(16).toUpperCase():r&lt;128?"%"+r.toString(16).toUpperCase():r&lt;2048?"%"+(r&gt;&gt;6|192).toString(16).toUpperCase()+"%"+(63&amp;r|128).toString(16).toUpperCase():"%"+(r&gt;&gt;12|224).toString(16).toUpperCase()+"%"+(r&gt;&gt;6&amp;63|128).toString(16).toUpperCase()+"%"+(63&amp;r|128).toString(16).toUpperCase()}</span>function <span class="fstat-no" title="function not covered" >d(</span>e){let r=<span class="cstat-no" title="statement not covered" >"",</span>t=<span class="cstat-no" title="statement not covered" >0;</span>const a=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>for(;t&lt;a;){const o=<span class="cstat-no" title="statement not covered" >parseInt(e.substr(t+1,2),16);<span class="cstat-no" title="statement not covered" ></span>if(o&lt;128)<span class="cstat-no" title="statement not covered" >r+=String.fromCharCode(o),t+=3;e</span>lse <span class="cstat-no" title="statement not covered" >if(o&gt;=194&amp;&amp;o&lt;224){<span class="cstat-no" title="statement not covered" >if(a-t&gt;=6){const a=<span class="cstat-no" title="statement not covered" >parseInt(e.substr(t+4,2),16);<span class="cstat-no" title="statement not covered" ></span>r+=String.fromCharCode((31&amp;o)&lt;&lt;6|63&amp;a)}</span>else <span class="cstat-no" title="statement not covered" >r+=e.substr(t,6);<span class="cstat-no" title="statement not covered" >t</span></span>+=6}</span>else <span class="cstat-no" title="statement not covered" >if(o&gt;=224){<span class="cstat-no" title="statement not covered" >if(a-t&gt;=9){const a=<span class="cstat-no" title="statement not covered" >parseInt(e.substr(t+4,2),16),</span>n=<span class="cstat-no" title="statement not covered" >parseInt(e.substr(t+7,2),16);<span class="cstat-no" title="statement not covered" ></span>r+=String.fromCharCode((15&amp;o)&lt;&lt;12|(63&amp;a)&lt;&lt;6|63&amp;n)}</span>else <span class="cstat-no" title="statement not covered" >r+=e.substr(t,9);<span class="cstat-no" title="statement not covered" >t</span></span>+=9}</span>else <span class="cstat-no" title="statement not covered" >r+=e.substr(t,3),t+=3}<span class="cstat-no" title="statement not covered" ></span></span></span></span>r</span>eturn r}</span>function m(e,r){function <span class="fstat-no" title="function not covered" >t(</span>e){const t=<span class="cstat-no" title="statement not covered" >d(e);<span class="cstat-no" title="statement not covered" ></span>return t.match(r.UNRESERVED)?t:e}</span>return e.scheme&amp;&amp;(e.scheme=String(e.scheme).replace(r.PCT_ENCODED,t).toLowerCase().replace(r.NOT_SCHEME,"")),void 0!==e.userinfo&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.userinfo=String(e.userinfo).replace(r.PCT_ENCODED,t).replace(r.NOT_USERINFO,p).replace(r.PCT_ENCODED,s))</span>,void 0!==e.host&amp;&amp;(e.host=String(e.host).replace(r.PCT_ENCODED,t).toLowerCase().replace(r.NOT_HOST,p).replace(r.PCT_ENCODED,s)),void 0!==e.path&amp;&amp;(e.path=String(e.path).replace(r.PCT_ENCODED,t).replace(e.scheme?r.NOT_PATH:r.NOT_PATH_NOSCHEME,p).replace(r.PCT_ENCODED,s)),void 0!==e.query&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.query=String(e.query).replace(r.PCT_ENCODED,t).replace(r.NOT_QUERY,p).replace(r.PCT_ENCODED,s))</span>,void 0!==e.fragment&amp;&amp;(e.fragment=String(e.fragment).replace(r.PCT_ENCODED,t).replace(r.NOT_FRAGMENT,p).replace(r.PCT_ENCODED,s)),e}const v=/^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[\dA-F:.]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,y=void 0==="".match(/(){0}/)[1];function g(e,r={}){const t={},a=!1!==r.iri?l:<span class="branch-1 cbranch-no" title="branch not covered" >u;</span>"suffix"===r.reference&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e=(r.scheme?r.scheme+":":"")+"//"+e)</span>;const o=e.match(v);<span class="missing-if-branch" title="else path not taken" >E</span>if(o){y?(t.scheme=o[1],t.userinfo=o[3],t.host=o[4],t.port=parseInt(o[5],10),t.path=o[6]||"",t.query=o[7],t.fragment=o[8],isNaN(t.port)&amp;&amp;(t.port=o[5])):(<span class="branch-1 cbranch-no" title="branch not covered" >t.scheme=o[1]||void 0,t.userinfo=-1!==e.indexOf("@")?o[3]:void 0,t.host=-1!==e.indexOf("//")?o[4]:void 0,t.port=parseInt(o[5],10),t.path=o[6]||"",t.query=-1!==e.indexOf("?")?o[7]:void 0,t.fragment=-1!==e.indexOf("#")?o[8]:void 0,isNaN(t.port)&amp;&amp;(t.port=e.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)?o[4]:void 0))</span>,t.host&amp;&amp;(t.host=t.host.replace(a.IPV6ADDRESS,"$1")),void 0!==t.scheme||void 0!==t.userinfo||void 0!==t.host||void 0!==t.port||t.path||void 0!==t.query?void 0===t.scheme?<span class="branch-0 cbranch-no" title="branch not covered" >t.reference="relative":</span>void 0===t.fragment?t.reference="absolute":t.reference="uri":t.reference="same-document",r.reference&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"suffix"!==r.reference&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >r.reference!==t.reference&amp;</span>&amp;(<span class="branch-3 cbranch-no" title="branch not covered" >t.error=t.error||"URI is not a "+r.reference+" reference.")</span>;const n=f[(r.scheme||t.scheme||"").toLowerCase()];<span class="missing-if-branch" title="if path not taken" >I</span>if(r.unicodeSupport||n&amp;&amp;n.unicodeSupport)<span class="cstat-no" title="statement not covered" >m(t,a);e</span>lse{if(t.host&amp;&amp;(r.domainHost||n&amp;&amp;n.domainHost))try{t.host=h.a.toASCII(t.host.replace(a.PCT_ENCODED,d).toLowerCase())}catch(e){<span class="cstat-no" title="statement not covered" >t.error=t.error||"Host's domain name can not be converted to ASCII via punycode: "+e}</span>m(t,u)}n&amp;&amp;n.parse&amp;&amp;n.parse(t,r)}else <span class="cstat-no" title="statement not covered" >t.error=t.error||"URI can not be parsed.";r</span>eturn t}const P=/^\.\.?\//,E=/^\/\.(\/|$)/,b=/^\/\.\.(\/|$)/,w=/^\/?(?:.|\n)*?(?=\/|$)/;function _(e){const r=[];for(;e.length;)<span class="missing-if-branch" title="if path not taken" >I</span>if(e.match(P))<span class="cstat-no" title="statement not covered" >e=e.replace(P,"");e</span>lse <span class="missing-if-branch" title="if path not taken" >I</span>if(e.match(E))<span class="cstat-no" title="statement not covered" >e=e.replace(E,"/");e</span>lse <span class="missing-if-branch" title="if path not taken" >I</span>if(e.match(b))<span class="cstat-no" title="statement not covered" >e=e.replace(b,"/"),r.pop();e</span>lse <span class="missing-if-branch" title="if path not taken" >I</span>if("."===e||".."===e)<span class="cstat-no" title="statement not covered" >e="";e</span>lse{const t=e.match(w);<span class="missing-if-branch" title="if path not taken" >I</span>if(!t)<span class="cstat-no" title="statement not covered" >throw new Error("Unexpected dot segment condition");{</span>const a=t[0];e=e.slice(a.length),r.push(a)}}return r.join("")}function S(e,r={}){const t=r.iri?<span class="branch-0 cbranch-no" title="branch not covered" >l:</span>u,a=[],o=f[(r.scheme||e.scheme||"").toLowerCase()];if(o&amp;&amp;o.serialize&amp;&amp;o.serialize(e,r),e.host)<span class="missing-if-branch" title="if path not taken" >I</span>if(t.IPV6ADDRESS.test(e.host));else <span class="missing-if-branch" title="else path not taken" >E</span>if(r.domainHost||o&amp;&amp;o.domainHost)try{e.host=r.iri?<span class="branch-0 cbranch-no" title="branch not covered" >h.a.toUnicode(e.host):</span>h.a.toASCII(e.host.replace(t.PCT_ENCODED,d).toLowerCase())}catch(t){<span class="cstat-no" title="statement not covered" >e.error=e.error||"Host's domain name can not be converted to "+(r.iri?"Unicode":"ASCII")+" via punycode: "+t}</span>m(e,t),"suffix"!==r.reference&amp;&amp;e.scheme&amp;&amp;(a.push(e.scheme),a.push(":"));const n=function(e,r){const t=!1!==r.iri?l:<span class="branch-1 cbranch-no" title="branch not covered" >u,</span>a=[];return void 0!==e.userinfo&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a.push(e.userinfo),a.push("@"))</span>,void 0!==e.host&amp;&amp;a.push(String(e.host).replace(t.IPV6ADDRESS,"[$1]")),"number"==typeof e.port&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a.push(":"),a.push(e.port.toString(10)))</span>,a.length?a.join(""):void 0}(e,r);<span class="missing-if-branch" title="else path not taken" >E</span>if(void 0!==n&amp;&amp;("suffix"!==r.reference&amp;&amp;a.push("//"),a.push(n),e.path&amp;&amp;"/"!==e.path.charAt(0)&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >a.push("/"))</span>,void 0!==e.path){let t=e.path;r.absolutePath||o&amp;&amp;o.absolutePath||(t=_(t)),void 0===n&amp;&amp;(t=t.replace(/^\/\//,"/%2F")),a.push(t)}return void 0!==e.query&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a.push("?"),a.push(e.query))</span>,void 0!==e.fragment&amp;&amp;(a.push("#"),a.push(e.fragment)),a.join("")}function x(e,r,t={},a){const o={};return a||(<span class="branch-1 cbranch-no" title="branch not covered" >e=g(S(e,t),t),r=g(S(r,t),t))</span>,!(t=t||<span class="branch-1 cbranch-no" title="branch not covered" >{})</span>.tolerant&amp;&amp;r.scheme?(o.scheme=r.scheme,o.userinfo=r.userinfo,o.host=r.host,o.port=r.port,o.path=_(r.path||<span class="branch-1 cbranch-no" title="branch not covered" >"")</span>,o.query=r.query):(void 0!==r.userinfo||void 0!==r.host||void 0!==r.port?(<span class="branch-0 cbranch-no" title="branch not covered" >o.userinfo=r.userinfo,o.host=r.host,o.port=r.port,o.path=_(r.path||""),o.query=r.query)</span>:(r.path?(<span class="branch-0 cbranch-no" title="branch not covered" >"/"===r.path.charAt(0)?o.path=_(r.path):(void 0===e.userinfo&amp;&amp;void 0===e.host&amp;&amp;void 0===e.port||e.path?e.path?o.path=e.path.slice(0,e.path.lastIndexOf("/")+1)+r.path:o.path=r.path:o.path="/"+r.path,o.path=_(o.path)),o.query=r.query)</span>:(o.path=e.path,void 0!==r.query?<span class="branch-0 cbranch-no" title="branch not covered" >o.query=r.query:</span>o.query=e.query),o.userinfo=e.userinfo,o.host=e.host,o.port=e.port),o.scheme=e.scheme),o.fragment=r.fragment,o}function R(e,r,t){return S(x(g(e,t),g(r,t),t,!0),t)}function <span class="fstat-no" title="function not covered" >O(</span>e,r){<span class="cstat-no" title="statement not covered" >return"string"==typeof e?e=S(g(e,r),r):"object"===n(e)&amp;&amp;(e=g(S(e,r),r)),e}</span>function <span class="fstat-no" title="function not covered" >j(</span>e,r,t){<span class="cstat-no" title="statement not covered" >return"string"==typeof e?e=S(g(e,t),t):"object"===n(e)&amp;&amp;(e=S(e,t)),"string"==typeof r?r=S(g(r,t),t):"object"===n(r)&amp;&amp;(r=S(r,t)),e===r}</span>function <span class="fstat-no" title="function not covered" >A(</span>e,r){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.toString().replace(r&amp;&amp;r.iri?l.ESCAPE:u.ESCAPE,p)}</span>function <span class="fstat-no" title="function not covered" >F(</span>e,r){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.toString().replace(r&amp;&amp;r.iri?l.PCT_ENCODED:u.PCT_ENCODED,d)}</span>var D={scheme:"http",domainHost:!0,parse:function(e,r){return e.host||(<span class="branch-1 cbranch-no" title="branch not covered" >e.error=e.error||"HTTP URIs must have a host.")</span>,e},serialize:function(e,r){return e.port!==("https"!==String(e.scheme).toLowerCase()?80:443)&amp;&amp;""!==e.port||(<span class="branch-2 cbranch-no" title="branch not covered" >e.port=void 0)</span>,e.path||(<span class="branch-1 cbranch-no" title="branch not covered" >e.path="/")</span>,e}},$={scheme:"https",domainHost:D.domainHost,parse:D.parse,serialize:D.serialize};const k={},I="[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",C=o(o("%[EFef][0-9A-Fa-f]%[0-9A-Fa-f][0-9A-Fa-f]%[0-9A-Fa-f][0-9A-Fa-f]")+"|"+o("%[89A-Fa-f][0-9A-Fa-f]%[0-9A-Fa-f][0-9A-Fa-f]")+"|"+o("%[0-9A-Fa-f][0-9A-Fa-f]")),T="[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",M="[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\&lt;\\&gt;A-Z\\x5E-\\x7E]",U=a(M,'[\\"\\\\]'),N=o(T+"+"+o("\\."+T+"+")+"*"),z=o('\\"'+o(M+"|"+o("\\\\"+U))+'*\\"'),L=o(I+"|"+C+"|[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"),B=o(N+"|\\[[\\x21-\\x5A\\x5E-\\x7E]*\\]"),V=o(o(N+"|"+z)+"\\@"+B),Q=o(V+o("\\,"+V)+"*"),q=o(L+"*"),H=o(q+"\\="+q),Y=o(H+o("\\&amp;"+H)+"*"),J=o("\\?"+Y),K=(new RegExp("^mailto\\:"+Q+"?"+J+"?$"),new RegExp(I,"g")),W=new RegExp(C,"g"),Z=new RegExp(a("[^]",T,"[\\.]",'[\\"]',U),"g"),G=(new RegExp(a("[^]",T,"[\\.]","[\\[]","[\\x21-\\x5A\\x5E-\\x7E]","[\\]]"),"g"),new RegExp(a("[^]",I,"[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"),"g")),X=G;new RegExp("^"+Q+"$"),new RegExp("^"+Y+"$");function <span class="fstat-no" title="function not covered" >ee(</span>e){const r=<span class="cstat-no" title="statement not covered" >d(e);<span class="cstat-no" title="statement not covered" ></span>return r.match(K)?r:e}</span>var re={scheme:"mailto",parse:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){const t=<span class="cstat-no" title="statement not covered" >e.to=e.path?e.path.split(","):[];<span class="cstat-no" title="statement not covered" ></span>if(e.path=void 0,e.query){let a=<span class="cstat-no" title="statement not covered" >!1;</span>const o=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >e.query.split("&amp;");<span class="cstat-no" title="statement not covered" ></span>for(let s=0,i=n.length;s&lt;i;++s){const i=<span class="cstat-no" title="statement not covered" >n[s].split("=");<span class="cstat-no" title="statement not covered" ></span>switch(i[0]){case"to":const n=<span class="cstat-no" title="statement not covered" >i[1].split(",");<span class="cstat-no" title="statement not covered" ></span>for(let e=0,r=n.length;e&lt;r;++e)<span class="cstat-no" title="statement not covered" >t.push(n[e]);<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"subject":<span class="cstat-no" title="statement not covered" >e.subject=F(i[1],r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"body":<span class="cstat-no" title="statement not covered" >e.body=F(i[1],r);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >a=!0,o[F(i[0],r)]=F(i[1],r)}</span>}<span class="cstat-no" title="statement not covered" ></span>a</span>&amp;&amp;(e.headers=o)}<span class="cstat-no" title="statement not covered" ></span>e</span>.query=void 0;<span class="cstat-no" title="statement not covered" >f</span>or(let a=0,o=t.length;a&lt;o;++a){const o=<span class="cstat-no" title="statement not covered" >t[a].split("@");<span class="cstat-no" title="statement not covered" ></span>if(o[0]=F(o[0]),r.unicodeSupport)<span class="cstat-no" title="statement not covered" >o[1]=F(o[1],r).toLowerCase();e</span>lse <span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >o[1]=h.a.toASCII(F(o[1],r).toLowerCase())}</span>catch(r){<span class="cstat-no" title="statement not covered" >e.error=e.error||"Email address's domain name can not be converted to ASCII via punycode: "+r}<span class="cstat-no" title="statement not covered" ></span>t</span></span>[a]=o.join("@")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,serialize:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){const t=<span class="cstat-no" title="statement not covered" >null!=(a=e.to)?a instanceof Array?a:"number"!=typeof a.length||a.split||a.setInterval||a.call?[a]:Array.prototype.slice.call(a):[];</span>var a;<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >for(let a=0,o=t.length;a&lt;o;++a){const o=<span class="cstat-no" title="statement not covered" >String(t[a]),</span>n=<span class="cstat-no" title="statement not covered" >o.lastIndexOf("@"),</span>i=<span class="cstat-no" title="statement not covered" >o.slice(0,n).replace(W,ee).replace(W,s).replace(Z,p);</span>let u=<span class="cstat-no" title="statement not covered" >o.slice(n+1);<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >u=r.iri?h.a.toUnicode(u):h.a.toASCII(F(u,r).toLowerCase())}</span>catch(t){<span class="cstat-no" title="statement not covered" >e.error=e.error||"Email address's domain name can not be converted to "+(r.iri?"Unicode":"ASCII")+" via punycode: "+t}<span class="cstat-no" title="statement not covered" ></span>t</span>[a]=i+"@"+u}<span class="cstat-no" title="statement not covered" ></span>e</span>.path=t.join(",")}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >e.headers=e.headers||{};<span class="cstat-no" title="statement not covered" ></span>e.subject&amp;&amp;(o.subject=e.subject),e.body&amp;&amp;(o.body=e.body);c</span>onst n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e in o)<span class="cstat-no" title="statement not covered" >o[e]!==k[e]&amp;&amp;n.push(e.replace(W,ee).replace(W,s).replace(G,p)+"="+o[e].replace(W,ee).replace(W,s).replace(X,p));<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.length&amp;&amp;(e.query=n.join("&amp;")),e}</span>};const te="(?:[0-9A-Za-z][0-9A-Za-z\\-]{1,31})",ae=new RegExp("^urn\\:("+te+")$"),oe=(new RegExp("^("+te+")\\:((?:(?:(?:\\%[0-9A-Fa-f]{2})|[0-9A-Za-z\\(\\)\\+\\,\\-\\.\\:\\=\\@\\;\\$\\_\\!\\*\\'\\/\\?\\#])+))$"),/^([^\:]+)\:(.*)/),ne=/[\x00-\x20\\\"\&amp;\&lt;\&gt;\[\]\^\`\{\|\}\~\x7F-\xFF]/g;var se={scheme:"urn",parse:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){const t=<span class="cstat-no" title="statement not covered" >e.path&amp;&amp;e.path.match(oe);<span class="cstat-no" title="statement not covered" ></span>if(t){const a=<span class="cstat-no" title="statement not covered" >"urn:"+t[1].toLowerCase();</span>let o=<span class="cstat-no" title="statement not covered" >f[a];<span class="cstat-no" title="statement not covered" ></span>o||(o=f[a]={scheme:a,parse:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return e}</span>,serialize:f.urn.serialize}),e.scheme=a,e.path=t[2],e=o.parse(e,r)}</span>else <span class="cstat-no" title="statement not covered" >e.error=e.error||"URN can not be parsed.";<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,serialize:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){const t=<span class="cstat-no" title="statement not covered" >e.scheme||r.scheme;<span class="cstat-no" title="statement not covered" ></span>if(t&amp;&amp;"urn"!==t){const r=<span class="cstat-no" title="statement not covered" >t.match(ae)||["urn:"+t,t];<span class="cstat-no" title="statement not covered" ></span>e.scheme="urn",e.path=r[1]+":"+(e.path?e.path.replace(ne,p):"")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>};const ie=/^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;var ue={scheme:"urn:uuid",parse:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r.tolerant||e.path&amp;&amp;e.path.match(ie)||(e.error=e.error||"UUID is not valid."),e}</span>,serialize:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r.tolerant||e.path&amp;&amp;e.path.match(ie)?e.path=(e.path||"").toLowerCase():e.scheme=void 0,f.urn.serialize(e,r)}</span>};t.d(r,"SCHEMES",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return f}</span>),t.d(r,"pctEncChar",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return p}</span>),t.d(r,"pctDecChars",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return d}</span>),t.d(r,"parse",function(){return g}),t.d(r,"removeDotSegments",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return _}</span>),t.d(r,"serialize",function(){return S}),t.d(r,"resolveComponents",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return x}</span>),t.d(r,"resolve",function(){return R}),t.d(r,"normalize",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return O}</span>),t.d(r,"equal",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return j}</span>),t.d(r,"escapeComponent",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return A}</span>),t.d(r,"unescapeComponent",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return F}</span>),f.http=D,f.https=$,f.mailto=re,f.urn=se,f["urn:uuid"]=ue},function(e){e.exports={$schema:"http://json-schema.org/draft-07/schema#",$id:"http://json-schema.org/draft-07/schema#",title:"Core schema meta-schema",definitions:{schemaArray:{type:"array",minItems:1,items:{$ref:"#"}},nonNegativeInteger:{type:"integer",minimum:0},nonNegativeIntegerDefault0:{allOf:[{$ref:"#/definitions/nonNegativeInteger"},{default:0}]},simpleTypes:{enum:["array","boolean","integer","null","number","object","string"]},stringArray:{type:"array",items:{type:"string"},uniqueItems:!0,default:[]}},type:["object","boolean"],properties:{$id:{type:"string",format:"uri-reference"},$schema:{type:"string",format:"uri"},$ref:{type:"string",format:"uri-reference"},$comment:{type:"string"},title:{type:"string"},description:{type:"string"},default:!0,readOnly:{type:"boolean",default:!1},examples:{type:"array",items:!0},multipleOf:{type:"number",exclusiveMinimum:0},maximum:{type:"number"},exclusiveMaximum:{type:"number"},minimum:{type:"number"},exclusiveMinimum:{type:"number"},maxLength:{$ref:"#/definitions/nonNegativeInteger"},minLength:{$ref:"#/definitions/nonNegativeIntegerDefault0"},pattern:{type:"string",format:"regex"},additionalItems:{$ref:"#"},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}],default:!0},maxItems:{$ref:"#/definitions/nonNegativeInteger"},minItems:{$ref:"#/definitions/nonNegativeIntegerDefault0"},uniqueItems:{type:"boolean",default:!1},contains:{$ref:"#"},maxProperties:{$ref:"#/definitions/nonNegativeInteger"},minProperties:{$ref:"#/definitions/nonNegativeIntegerDefault0"},required:{$ref:"#/definitions/stringArray"},additionalProperties:{$ref:"#"},definitions:{type:"object",additionalProperties:{$ref:"#"},default:{}},properties:{type:"object",additionalProperties:{$ref:"#"},default:{}},patternProperties:{type:"object",additionalProperties:{$ref:"#"},propertyNames:{format:"regex"},default:{}},dependencies:{type:"object",additionalProperties:{anyOf:[{$ref:"#"},{$ref:"#/definitions/stringArray"}]}},propertyNames:{$ref:"#"},const:!0,enum:{type:"array",items:!0,minItems:1,uniqueItems:!0},type:{anyOf:[{$ref:"#/definitions/simpleTypes"},{type:"array",items:{$ref:"#/definitions/simpleTypes"},minItems:1,uniqueItems:!0}]},format:{type:"string"},contentMediaType:{type:"string"},contentEncoding:{type:"string"},if:{$ref:"#"},then:{$ref:"#"},else:{$ref:"#"},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"}},default:!0}},function(e){e.exports={$schema:"http://json-schema.org/draft-07/schema#",$id:"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#",description:"Meta-schema for $data reference (JSON Schema extension proposal)",type:"object",required:["$data"],properties:{$data:{type:"string",anyOf:[{format:"relative-json-pointer"},{format:"json-pointer"}]}},additionalProperties:!1}},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a,o,n=<span class="cstat-no" title="statement not covered" >" ",</span>s=<span class="cstat-no" title="statement not covered" >e.level,</span>i=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>u=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>l=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>c=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>h=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>f=<span class="cstat-no" title="statement not covered" >"data"+(i||""),</span>p=<span class="cstat-no" title="statement not covered" >"valid"+s,</span>d=<span class="cstat-no" title="statement not covered" >"errs__"+s,</span>m=<span class="cstat-no" title="statement not covered" >e.opts.$data&amp;&amp;u&amp;&amp;u.$data;<span class="cstat-no" title="statement not covered" ></span>m?(n+=" var schema"+s+" = "+e.util.getData(u.$data,i,e.dataPathArr)+"; ",o="schema"+s):o=u;v</span>ar v,y,g,P,E,b=<span class="cstat-no" title="statement not covered" >"definition"+s,</span>w=<span class="cstat-no" title="statement not covered" >this.definition,</span>_=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(m&amp;&amp;w.$data){<span class="cstat-no" title="statement not covered" >E="keywordValidate"+s;v</span>ar S=<span class="cstat-no" title="statement not covered" >w.validateSchema;<span class="cstat-no" title="statement not covered" ></span>n+=" var "+b+" = RULES.custom['"+r+"'].definition; var "+E+" = "+b+".validate;"}</span>else{<span class="cstat-no" title="statement not covered" >if(!(P=e.useCustomRule(this,u,e.schema,e)))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >o</span></span>="validate.schema"+l,E=P.code,v=w.compile,y=w.inline,g=w.macro}</span>v</span>ar x=<span class="cstat-no" title="statement not covered" >E+".errors",</span>R=<span class="cstat-no" title="statement not covered" >"i"+s,</span>O=<span class="cstat-no" title="statement not covered" >"ruleErr"+s,</span>j=<span class="cstat-no" title="statement not covered" >w.async;<span class="cstat-no" title="statement not covered" ></span>if(j&amp;&amp;!e.async)<span class="cstat-no" title="statement not covered" >throw new Error("async keyword in sync schema");<span class="cstat-no" title="statement not covered" >i</span></span>f(y||g||(n+=x+" = null;"),n+="var "+d+" = errors;var "+p+";",m&amp;&amp;w.$data&amp;&amp;(_+="}",n+=" if ("+o+" === undefined) { "+p+" = true; } else { ",S&amp;&amp;(_+="}",n+=" "+p+" = "+b+".validateSchema("+o+"); if ("+p+") { ")),y)<span class="cstat-no" title="statement not covered" >w.statements?n+=" "+P.validate+" ":n+=" "+p+" = "+P.validate+"; ";e</span>lse <span class="cstat-no" title="statement not covered" >if(g){var A=<span class="cstat-no" title="statement not covered" >e.util.copy(e);<span class="cstat-no" title="statement not covered" ></span>_="";<span class="cstat-no" title="statement not covered" >A</span>.level++;v</span>ar F=<span class="cstat-no" title="statement not covered" >"valid"+A.level;<span class="cstat-no" title="statement not covered" ></span>A.schema=P.validate,A.schemaPath="";v</span>ar D=<span class="cstat-no" title="statement not covered" >e.compositeRule;<span class="cstat-no" title="statement not covered" ></span>e.compositeRule=A.compositeRule=!0;v</span>ar $=<span class="cstat-no" title="statement not covered" >e.validate(A).replace(/validate\.schema/g,E);<span class="cstat-no" title="statement not covered" ></span>e.compositeRule=A.compositeRule=D,n+=" "+$}</span>else{<span class="cstat-no" title="statement not covered" >(T=T||[]).push(n),n="",n+="  "+E+".call( ",e.opts.passContext?n+="this":n+="self",v||!1===w.schema?n+=" , "+f+" ":n+=" , "+o+" , "+f+" , validate.schema"+e.schemaPath+" ",n+=" , (dataPath || '')",'""'!=e.errorPath&amp;&amp;(n+=" + "+e.errorPath);v</span>ar k=<span class="cstat-no" title="statement not covered" >i?"data"+(i-1||""):"parentData",</span>I=<span class="cstat-no" title="statement not covered" >i?e.dataPathArr[i]:"parentDataProperty",</span>C=<span class="cstat-no" title="statement not covered" >n+=" , "+k+" , "+I+" , rootData )  ";<span class="cstat-no" title="statement not covered" ></span>n=T.pop(),!1===w.errors?(n+=" "+p+" = ",j&amp;&amp;(n+="await "),n+=C+"; "):n+=j?" var "+(x="customErrors"+s)+" = null; try { "+p+" = await "+C+"; } catch (e) { "+p+" = false; if (e instanceof ValidationError) "+x+" = e.errors; else throw e; } ":" "+x+" = null; "+p+" = "+C+"; "}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(w.modifying&amp;&amp;(n+=" if ("+k+") "+f+" = "+k+"["+I+"];"),n+=""+_,w.valid)<span class="cstat-no" title="statement not covered" >h&amp;&amp;(n+=" if (true) { ");e</span>lse{var T;<span class="cstat-no" title="statement not covered" >n+=" if ( ",void 0===w.valid?(n+=" !",n+=g?""+F:""+p):n+=" "+!w.valid+" ",n+=") { ",a=this.keyword,(T=T||[]).push(n),n="",(T=T||[]).push(n),n="",!1!==e.createErrors?(n+=" { keyword: '"+(a||"custom")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { keyword: '"+this.keyword+"' } ",!1!==e.opts.messages&amp;&amp;(n+=" , message: 'should pass \""+this.keyword+"\" keyword validation' "),e.opts.verbose&amp;&amp;(n+=" , schema: validate.schema"+l+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+f+" "),n+=" } "):n+=" {} ";v</span>ar M=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>n=T.pop(),!e.compositeRule&amp;&amp;h?e.async?n+=" throw new ValidationError(["+M+"]); ":n+=" validate.errors = ["+M+"]; return false; ":n+=" var err = "+M+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";v</span>ar U=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>n=T.pop(),y?w.errors?"full"!=w.errors&amp;&amp;(n+="  for (var "+R+"="+d+"; "+R+"&lt;errors; "+R+"++) { var "+O+" = vErrors["+R+"]; if ("+O+".dataPath === undefined) "+O+".dataPath = (dataPath || '') + "+e.errorPath+"; if ("+O+".schemaPath === undefined) { "+O+'.schemaPath = "'+c+'"; } ',e.opts.verbose&amp;&amp;(n+=" "+O+".schema = "+o+"; "+O+".data = "+f+"; "),n+=" } "):!1===w.errors?n+=" "+U+" ":(n+=" if ("+d+" == errors) { "+U+" } else {  for (var "+R+"="+d+"; "+R+"&lt;errors; "+R+"++) { var "+O+" = vErrors["+R+"]; if ("+O+".dataPath === undefined) "+O+".dataPath = (dataPath || '') + "+e.errorPath+"; if ("+O+".schemaPath === undefined) { "+O+'.schemaPath = "'+c+'"; } ',e.opts.verbose&amp;&amp;(n+=" "+O+".schema = "+o+"; "+O+".data = "+f+"; "),n+=" } } "):g?(n+="   var err =   ",!1!==e.createErrors?(n+=" { keyword: '"+(a||"custom")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { keyword: '"+this.keyword+"' } ",!1!==e.opts.messages&amp;&amp;(n+=" , message: 'should pass \""+this.keyword+"\" keyword validation' "),e.opts.verbose&amp;&amp;(n+=" , schema: validate.schema"+l+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+f+" "),n+=" } "):n+=" {} ",n+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&amp;&amp;h&amp;&amp;(e.async?n+=" throw new ValidationError(vErrors); ":n+=" validate.errors = vErrors; return false; ")):!1===w.errors?n+=" "+U+" ":(n+=" if (Array.isArray("+x+")) { if (vErrors === null) vErrors = "+x+"; else vErrors = vErrors.concat("+x+"); errors = vErrors.length;  for (var "+R+"="+d+"; "+R+"&lt;errors; "+R+"++) { var "+O+" = vErrors["+R+"]; if ("+O+".dataPath === undefined) "+O+".dataPath = (dataPath || '') + "+e.errorPath+";  "+O+'.schemaPath = "'+c+'";  ',e.opts.verbose&amp;&amp;(n+=" "+O+".schema = "+o+"; "+O+".data = "+f+"; "),n+=" } } else { "+U+" } "),n+=" } ",h&amp;&amp;(n+=" else { ")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>},function(e,r,t){"use strict";var a=/^[a-z_$][a-z0-9_$-]*$/i,o=t(24);e.exports={add:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var t=<span class="cstat-no" title="statement not covered" >this.RULES;<span class="cstat-no" title="statement not covered" ></span>if(t.keywords[e])<span class="cstat-no" title="statement not covered" >throw new Error("Keyword "+e+" is already defined");<span class="cstat-no" title="statement not covered" >i</span></span>f(!a.test(e))<span class="cstat-no" title="statement not covered" >throw new Error("Keyword "+e+" is not a valid identifier");<span class="cstat-no" title="statement not covered" >i</span></span>f(r){<span class="cstat-no" title="statement not covered" >if(r.macro&amp;&amp;void 0!==r.valid)<span class="cstat-no" title="statement not covered" >throw new Error('"valid" option cannot be used with macro keywords');v</span></span>ar n=<span class="cstat-no" title="statement not covered" >r.type;<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(n)){var s,i=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>for(s=0;s&lt;i;s++)<span class="cstat-no" title="statement not covered" >h(n[s]);<span class="cstat-no" title="statement not covered" >f</span></span>or(s=0;s&lt;i;s++)<span class="cstat-no" title="statement not covered" >c(e,n[s],r)}</span></span>else <span class="cstat-no" title="statement not covered" >n&amp;&amp;h(n),c(e,n,r);v</span></span>ar u=<span class="cstat-no" title="statement not covered" >!0===r.$data&amp;&amp;this._opts.$data;<span class="cstat-no" title="statement not covered" ></span>if(u&amp;&amp;!r.validate)<span class="cstat-no" title="statement not covered" >throw new Error('$data support: "validate" function is not defined');v</span></span>ar l=<span class="cstat-no" title="statement not covered" >r.metaSchema;<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;(u&amp;&amp;(l={anyOf:[l,{$ref:"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#"}]}),r.validateSchema=this.compile(l,!0))}</span>f</span>unction <span class="fstat-no" title="function not covered" >c(</span>e,r,a){<span class="cstat-no" title="statement not covered" >for(var n,s=0;s&lt;t.length;s++){var i=<span class="cstat-no" title="statement not covered" >t[s];<span class="cstat-no" title="statement not covered" ></span>if(i.type==r){<span class="cstat-no" title="statement not covered" >n=i;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>n</span>||(n={type:r,rules:[]},t.push(n));v</span>ar u=<span class="cstat-no" title="statement not covered" >{keyword:e,definition:a,custom:!0,code:o,implements:a.implements};<span class="cstat-no" title="statement not covered" ></span>n.rules.push(u),t.custom[e]=u}</span>function <span class="fstat-no" title="function not covered" >h(</span>e){<span class="cstat-no" title="statement not covered" >if(!t.types[e])<span class="cstat-no" title="statement not covered" >throw new Error("Unknown type "+e)}<span class="cstat-no" title="statement not covered" ></span></span>return t.keywords[e]=t.all[e]=!0,this}</span>,get:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this.RULES.custom[e];<span class="cstat-no" title="statement not covered" ></span>return r?r.definition:this.RULES.keywords[e]||!1}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this.RULES;<span class="cstat-no" title="statement not covered" ></span>delete r.keywords[e],delete r.all[e],delete r.custom[e];<span class="cstat-no" title="statement not covered" >f</span>or(var t=0;t&lt;r.length;t++)<span class="cstat-no" title="statement not covered" >for(var a=r[t].rules,o=0;o&lt;a.length;o++)<span class="cstat-no" title="statement not covered" >if(a[o].keyword==e){<span class="cstat-no" title="statement not covered" >a.splice(o,1);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn this}</span>}},function(e,r,t){"use strict";var a=t(3).MissingRef;e.exports=function <span class="fstat-no" title="function not covered" >e(</span>r,t,o){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if("function"!=typeof this._opts.loadSchema)<span class="cstat-no" title="statement not covered" >throw new Error("options.loadSchema should be a function");<span class="cstat-no" title="statement not covered" >"</span></span>function"==typeof t&amp;&amp;(o=t,t=void 0);v</span>ar s=<span class="cstat-no" title="statement not covered" >i(r).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >n._addSchema(r,void 0,t);<span class="cstat-no" title="statement not covered" ></span>return e.validate||function <span class="fstat-no" title="function not covered" >e(</span>r){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return n._compile(r)}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(e instanceof a)<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >o(</span>e){var o=<span class="cstat-no" title="statement not covered" >e.missingSchema;<span class="cstat-no" title="statement not covered" ></span>if(l(o))<span class="cstat-no" title="statement not covered" >throw new Error("Schema "+o+" is loaded but "+e.missingRef+" cannot be resolved");v</span></span>ar s=<span class="cstat-no" title="statement not covered" >n._loadingSchemas[o];<span class="cstat-no" title="statement not covered" ></span>s||(s=n._loadingSchemas[o]=n._opts.loadSchema(o)).then(u,u);<span class="cstat-no" title="statement not covered" >r</span>eturn s.then(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!l(o))<span class="cstat-no" title="statement not covered" >return i(e).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l(o)||n.addSchema(e,o,void 0,t)}</span>)}</span></span>).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >e(</span>r){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return n._compile(r)}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(e instanceof a)<span class="cstat-no" title="statement not covered" >return o(e);<span class="cstat-no" title="statement not covered" >t</span></span>hrow e}</span>f</span>unction <span class="fstat-no" title="function not covered" >o(</span>a){var o=<span class="cstat-no" title="statement not covered" >a.missingSchema;<span class="cstat-no" title="statement not covered" ></span>if(l(o))<span class="cstat-no" title="statement not covered" >throw new Error("Schema "+o+" is loaded but "+a.missingRef+" cannot be resolved");v</span></span>ar s=<span class="cstat-no" title="statement not covered" >n._loadingSchemas[o];<span class="cstat-no" title="statement not covered" ></span>return s||(s=n._loadingSchemas[o]=n._opts.loadSchema(o)).then(u,u),s.then(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!l(o))<span class="cstat-no" title="statement not covered" >return i(e).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l(o)||n.addSchema(e,o,void 0,t)}</span>)}</span></span>).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e(r)}</span>);f</span>unction <span class="fstat-no" title="function not covered" >u(</span>){<span class="cstat-no" title="statement not covered" >delete n._loadingSchemas[o]}</span>function <span class="fstat-no" title="function not covered" >l(</span>e){<span class="cstat-no" title="statement not covered" >return n._refs[e]||n._schemas[e]}</span>}}(r)}</span>);f</span>unction <span class="fstat-no" title="function not covered" >u(</span>){<span class="cstat-no" title="statement not covered" >delete n._loadingSchemas[o]}</span>function <span class="fstat-no" title="function not covered" >l(</span>e){<span class="cstat-no" title="statement not covered" >return n._refs[e]||n._schemas[e]}</span>}(e);<span class="cstat-no" title="statement not covered" >t</span></span>hrow e}</span>f</span>unction <span class="fstat-no" title="function not covered" >o(</span>a){var o=<span class="cstat-no" title="statement not covered" >a.missingSchema;<span class="cstat-no" title="statement not covered" ></span>if(l(o))<span class="cstat-no" title="statement not covered" >throw new Error("Schema "+o+" is loaded but "+a.missingRef+" cannot be resolved");v</span></span>ar s=<span class="cstat-no" title="statement not covered" >n._loadingSchemas[o];<span class="cstat-no" title="statement not covered" ></span>return s||(s=n._loadingSchemas[o]=n._opts.loadSchema(o)).then(u,u),s.then(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!l(o))<span class="cstat-no" title="statement not covered" >return i(e).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l(o)||n.addSchema(e,o,void 0,t)}</span>)}</span></span>).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e(r)}</span>);f</span>unction <span class="fstat-no" title="function not covered" >u(</span>){<span class="cstat-no" title="statement not covered" >delete n._loadingSchemas[o]}</span>function <span class="fstat-no" title="function not covered" >l(</span>e){<span class="cstat-no" title="statement not covered" >return n._refs[e]||n._schemas[e]}</span>}}(e)}</span>);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;s.then(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o(null,e)}</span>,o);<span class="cstat-no" title="statement not covered" >r</span>eturn s;f</span>unction <span class="fstat-no" title="function not covered" >i(</span>r){var t=<span class="cstat-no" title="statement not covered" >r.$schema;<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;!n.getSchema(t)?e.call(n,{$ref:t},!0):Promise.resolve()}</span>}},function(e,r,t){"use strict";var a=["multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","maxLength","minLength","pattern","additionalItems","maxItems","minItems","uniqueItems","maxProperties","minProperties","required","additionalProperties","enum","format","const"];e.exports=function(e,r){for(var t=0;t&lt;r.length;t++){e=JSON.parse(JSON.stringify(e));var o,n=r[t].split("/"),s=e;for(o=1;o&lt;n.length;o++)s=s[n[o]];for(o=0;o&lt;a.length;o++){var i=a[o],u=s[i];u&amp;&amp;(s[i]={anyOf:[u,{$ref:"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#"}]})}}return e}},function(e,r,t){"use strict";e.exports=function(e,r,t){var a,o=" ",n=e.level,s=e.dataLevel,i=e.schema[r],u=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(s||<span class="branch-1 cbranch-no" title="branch not covered" >"")</span>,f="valid"+n,p=e.opts.$data&amp;&amp;i&amp;&amp;i.$data;<span class="missing-if-branch" title="else path not taken" >E</span>if(p?(<span class="branch-0 cbranch-no" title="branch not covered" >o+=" var schema"+n+" = "+e.util.getData(i.$data,s,e.dataPathArr)+"; ",a="schema"+n)</span>:a=i,(i||<span class="branch-1 cbranch-no" title="branch not covered" >p)</span>&amp;&amp;!1!==e.opts.uniqueItems){p&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o+=" var "+f+"; if ("+a+" === false || "+a+" === undefined) "+f+" = true; else if (typeof "+a+" != 'boolean') "+f+" = false; else { ")</span>,o+=" var i = "+h+".length , "+f+" = true , j; if (i &gt; 1) { ";var d=e.schema.items&amp;&amp;e.schema.items.type,m=Array.isArray(d);if(!d||"object"==d||"array"==d||m&amp;&amp;(<span class="branch-4 cbranch-no" title="branch not covered" >d.indexOf("object")&gt;=0|</span>|<span class="branch-5 cbranch-no" title="branch not covered" >d.indexOf("array")&gt;=0)</span>)o+=" outer: for (;i--;) { for (j = i; j--;) { if (equal("+h+"[i], "+h+"[j])) { "+f+" = false; break outer; } } } ";else{o+=" var itemIndices = {}, item; for (;i--;) { var item = "+h+"[i]; ";var v="checkDataType"+(m?<span class="branch-0 cbranch-no" title="branch not covered" >"s":</span>"");o+=" if ("+e.util[v](d,"item",!0)+") continue; ",m&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o+=" if (typeof item == 'string') item = '\"' + item; ")</span>,o+=" if (typeof itemIndices[item] == 'number') { "+f+" = false; j = itemIndices[item]; break; } itemIndices[item] = i; } "}o+=" } ",p&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o+="  }  ")</span>,o+=" if (!"+f+") {   ";var y=y||[];y.push(o),o="",!1!==e.createErrors?(o+=" { keyword: 'uniqueItems' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { i: i, j: j } ",!1!==e.opts.messages&amp;&amp;(o+=" , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o+=" , schema:  ",o+=p?"validate.schema"+u:""+i,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" ")</span>,o+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >o+=" {} ";</span>var g=o;o=y.pop(),!e.compositeRule&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >c?<span class="branch-0 cbranch-no" title="branch not covered" ></span>e.async?o+=" throw new ValidationError(["+g+"]); ":o+=" validate.errors = ["+g+"]; return false; ":</span>o+=" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+=" } ",c&amp;&amp;(o+=" else { ")}else <span class="cstat-no" title="statement not covered" >c&amp;&amp;(o+=" if (true) { ");r</span>eturn o}},function(e,r,t){"use strict";e.exports=function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,s=e.schema[r],i=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,l=!e.opts.allErrors,c="data"+(n||<span class="branch-1 cbranch-no" title="branch not covered" >"")</span>,h="valid"+o,f=e.opts.$data&amp;&amp;s&amp;&amp;s.$data;f&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" var schema"+o+" = "+e.util.getData(s.$data,n,e.dataPathArr)+"; ")</span>;var p="schema"+o;<span class="missing-if-branch" title="else path not taken" >E</span>if(!f)<span class="missing-if-branch" title="else path not taken" >E</span>if(s.length&lt;e.opts.loopRequired&amp;&amp;e.schema.properties&amp;&amp;Object.keys(e.schema.properties).length){var d=[],m=s;<span class="missing-if-branch" title="else path not taken" >E</span>if(m)for(var v,y=-1,g=m.length-1;y&lt;g;){v=m[y+=1];var P=e.schema.properties[v];P&amp;&amp;e.util.schemaHasRules(P,e.RULES.all)||(<span class="branch-2 cbranch-no" title="branch not covered" >d[d.length]=v)</span>}}else <span class="cstat-no" title="statement not covered" >d=s;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(f||d.length){var E=<span class="cstat-no" title="statement not covered" >e.errorPath,</span>b=<span class="cstat-no" title="statement not covered" >f||d.length&gt;=e.opts.loopRequired,</span>w=<span class="cstat-no" title="statement not covered" >e.opts.ownProperties;<span class="cstat-no" title="statement not covered" ></span>if(l)<span class="cstat-no" title="statement not covered" >if(a+=" var missing"+o+"; ",b){<span class="cstat-no" title="statement not covered" >f||(a+=" var "+p+" = validate.schema"+i+"; ");v</span>ar _=<span class="cstat-no" title="statement not covered" >"' + "+(A="schema"+o+"["+(R="i"+o)+"]")+" + '";<span class="cstat-no" title="statement not covered" ></span>e.opts._errorDataPathProperty&amp;&amp;(e.errorPath=e.util.getPathExpr(E,A,e.opts.jsonPointers)),a+=" var "+h+" = true; ",f&amp;&amp;(a+=" if (schema"+o+" === undefined) "+h+" = true; else if (!Array.isArray(schema"+o+")) "+h+" = false; else {"),a+=" for (var "+R+" = 0; "+R+" &lt; "+p+".length; "+R+"++) { "+h+" = "+c+"["+p+"["+R+"]] !== undefined ",w&amp;&amp;(a+=" &amp;&amp;   Object.prototype.hasOwnProperty.call("+c+", "+p+"["+R+"]) "),a+="; if (!"+h+") break; } ",f&amp;&amp;(a+="  }  "),a+="  if (!"+h+") {   ",(j=j||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { missingProperty: '"+_+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+_+"\\'",a+="' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";v</span>ar S=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>a=j.pop(),!e.compositeRule&amp;&amp;l?e.async?a+=" throw new ValidationError(["+S+"]); ":a+=" validate.errors = ["+S+"]; return false; ":a+=" var err = "+S+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { "}</span>else{<span class="cstat-no" title="statement not covered" >a+=" if ( ";v</span>ar x=<span class="cstat-no" title="statement not covered" >d;<span class="cstat-no" title="statement not covered" ></span>if(x)<span class="cstat-no" title="statement not covered" >for(var R=-1,O=x.length-1;R&lt;O;){<span class="cstat-no" title="statement not covered" >D=x[R+=1],R&amp;&amp;(a+=" || "),a+=" ( ( "+(C=c+(I=e.util.getProperty(D)))+" === undefined ",w&amp;&amp;(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(D)+"') "),a+=") &amp;&amp; (missing"+o+" = "+e.util.toQuotedString(e.opts.jsonPointers?D:I)+") ) "}<span class="cstat-no" title="statement not covered" ></span>a</span></span>+=") {  ";v</span>ar j;<span class="cstat-no" title="statement not covered" >_="' + "+(A="missing"+o)+" + '";<span class="cstat-no" title="statement not covered" >e</span>.opts._errorDataPathProperty&amp;&amp;(e.errorPath=e.opts.jsonPointers?e.util.getPathExpr(E,A,!0):E+" + "+A),(j=j||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { missingProperty: '"+_+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+_+"\\'",a+="' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";<span class="cstat-no" title="statement not covered" >S</span>=a;<span class="cstat-no" title="statement not covered" >a</span>=j.pop(),!e.compositeRule&amp;&amp;l?e.async?a+=" throw new ValidationError(["+S+"]); ":a+=" validate.errors = ["+S+"]; return false; ":a+=" var err = "+S+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { "}</span>e</span>lse <span class="cstat-no" title="statement not covered" >if(b){<span class="cstat-no" title="statement not covered" >f||(a+=" var "+p+" = validate.schema"+i+"; ");v</span>ar A;<span class="cstat-no" title="statement not covered" >_="' + "+(A="schema"+o+"["+(R="i"+o)+"]")+" + '";<span class="cstat-no" title="statement not covered" >e</span>.opts._errorDataPathProperty&amp;&amp;(e.errorPath=e.util.getPathExpr(E,A,e.opts.jsonPointers)),f&amp;&amp;(a+=" if ("+p+" &amp;&amp; !Array.isArray("+p+")) {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { missingProperty: '"+_+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+_+"\\'",a+="' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if ("+p+" !== undefined) { "),a+=" for (var "+R+" = 0; "+R+" &lt; "+p+".length; "+R+"++) { if ("+c+"["+p+"["+R+"]] === undefined ",w&amp;&amp;(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", "+p+"["+R+"]) "),a+=") {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { missingProperty: '"+_+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+_+"\\'",a+="' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ",f&amp;&amp;(a+="  }  ")}</span>else{var F=<span class="cstat-no" title="statement not covered" >d;<span class="cstat-no" title="statement not covered" ></span>if(F)<span class="cstat-no" title="statement not covered" >for(var D,$=-1,k=F.length-1;$&lt;k;){<span class="cstat-no" title="statement not covered" >D=F[$+=1];v</span>ar I=<span class="cstat-no" title="statement not covered" >e.util.getProperty(D),</span>C=(<span class="cstat-no" title="statement not covered" >_=e.util.escapeQuotes(D),c+I)</span>;<span class="cstat-no" title="statement not covered" >e.opts._errorDataPathProperty&amp;&amp;(e.errorPath=e.util.getPath(E,D,e.opts.jsonPointers)),a+=" if ( "+C+" === undefined ",w&amp;&amp;(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(D)+"') "),a+=") {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { missingProperty: '"+_+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+_+"\\'",a+="' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "}</span>}<span class="cstat-no" title="statement not covered" ></span></span>e</span></span>.errorPath=E}</span>else l&amp;&amp;(a+=" if (true) {");return a}},function(e,r,t){"use strict";e.exports=function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,s=e.schema[r],i=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,l=!e.opts.allErrors,c="data"+(n||<span class="branch-1 cbranch-no" title="branch not covered" >"")</span>,h="errs__"+o,f=e.util.copy(e);f.level++;var p="valid"+f.level;<span class="missing-if-branch" title="else path not taken" >E</span>if(e.util.schemaHasRules(s,e.RULES.all)){f.schema=s,f.schemaPath=i,f.errSchemaPath=u;var d="key"+o,m="idx"+o,v="i"+o,y="' + "+d+" + '",g="data"+(f.dataLevel=e.dataLevel+1),P="dataProperties"+o,E=e.opts.ownProperties,b=e.baseId;a+=" var "+h+" = errors; ",E&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" var "+P+" = undefined; ")</span>,a+=E?<span class="branch-0 cbranch-no" title="branch not covered" >" "+P+" = "+P+" || Object.keys("+c+"); for (var "+m+"=0; "+m+"&lt;"+P+".length; "+m+"++) { var "+d+" = "+P+"["+m+"]; ":</span>" for (var "+d+" in "+c+") { ",a+=" var startErrs"+o+" = errors; ";var w=d,_=e.compositeRule;e.compositeRule=f.compositeRule=!0;var S=e.validate(f);f.baseId=b,e.util.varOccurences(S,g)&lt;2?<span class="branch-0 cbranch-no" title="branch not covered" >a+=" "+e.util.varReplace(S,g,w)+" ":</span>a+=" var "+g+" = "+w+"; "+S+" ",e.compositeRule=f.compositeRule=_,a+=" if (!"+p+") { for (var "+v+"=startErrs"+o+"; "+v+"&lt;errors; "+v+"++) { vErrors["+v+"].propertyName = "+d+"; }   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'propertyNames' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { propertyName: '"+y+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'property name \\'"+y+"\\' is invalid' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" ")</span>,a+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >a+=" {} ",</span>a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&amp;&amp;l&amp;&amp;(e.async?<span class="branch-0 cbranch-no" title="branch not covered" >a+=" throw new ValidationError(vErrors); ":</span>a+=" validate.errors = vErrors; return false; "),l&amp;&amp;(a+=" break; "),a+=" } }"}return l&amp;&amp;(a+="  if ("+h+" == errors) {"),a=e.util.cleanUpCode(a)}},function(e,r,t){"use strict";e.exports=function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,s=e.schema[r],i=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,l=!e.opts.allErrors,c="data"+(n||""),h="errs__"+o,f=e.util.copy(e),p="";f.level++;var d="valid"+f.level,m="key"+o,v="idx"+o,y=f.dataLevel=e.dataLevel+1,g="data"+y,P="dataProperties"+o,E=Object.keys(s||{}),b=e.schema.patternProperties||{},w=Object.keys(b),_=e.schema.additionalProperties,S=E.length||w.length,x=!1===_,R="object"==typeof _&amp;&amp;Object.keys(_).length,O=e.opts.removeAdditional,j=x||R||O,A=e.opts.ownProperties,F=e.baseId,D=e.schema.required;if(D&amp;&amp;(!e.opts.$data||!D.$data)&amp;&amp;D.length&lt;e.opts.loopRequired)var $=e.util.toHash(D);if(a+="var "+h+" = errors;var "+d+" = true;",A&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" var "+P+" = undefined;")</span>,j){if(a+=A?<span class="branch-0 cbranch-no" title="branch not covered" >" "+P+" = "+P+" || Object.keys("+c+"); for (var "+v+"=0; "+v+"&lt;"+P+".length; "+v+"++) { var "+m+" = "+P+"["+v+"]; ":</span>" for (var "+m+" in "+c+") { ",S){<span class="missing-if-branch" title="else path not taken" >E</span>if(a+=" var isAdditional"+o+" = !(false ",E.length)<span class="missing-if-branch" title="if path not taken" >I</span>if(E.length&gt;8)<span class="cstat-no" title="statement not covered" >a+=" || validate.schema"+i+".hasOwnProperty("+m+") ";e</span>lse{var k=E;<span class="missing-if-branch" title="else path not taken" >E</span>if(k)for(var I=-1,C=k.length-1;I&lt;C;)J=k[I+=1],a+=" || "+m+" == "+e.util.toQuotedString(J)+" "}<span class="missing-if-branch" title="if path not taken" >I</span>if(w.length){var T=<span class="cstat-no" title="statement not covered" >w;<span class="cstat-no" title="statement not covered" ></span>if(T)<span class="cstat-no" title="statement not covered" >for(var M=-1,U=T.length-1;M&lt;U;)<span class="cstat-no" title="statement not covered" >oe=T[M+=1],a+=" || "+e.usePattern(oe)+".test("+m+") "}</span></span></span>a+=" ); if (isAdditional"+o+") { "}<span class="missing-if-branch" title="if path not taken" >I</span>if("all"==O)<span class="cstat-no" title="statement not covered" >a+=" delete "+c+"["+m+"]; ";e</span>lse{var N=e.errorPath,z="' + "+m+" + '";if(e.opts._errorDataPathProperty&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.errorPath=e.util.getPathExpr(e.errorPath,m,e.opts.jsonPointers))</span>,x)<span class="missing-if-branch" title="if path not taken" >I</span>if(O)<span class="cstat-no" title="statement not covered" >a+=" delete "+c+"["+m+"]; ";e</span>lse{a+=" "+d+" = false; ";var L=u;u=e.errSchemaPath+"/additionalProperties",(re=re||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'additionalProperties' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { additionalProperty: '"+z+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: '",e.opts._errorDataPathProperty?<span class="branch-0 cbranch-no" title="branch not covered" >a+="is an invalid additional property":</span>a+="should NOT have additional properties",a+="' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" ")</span>,a+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >a+=" {} ";</span>var B=a;a=re.pop(),!e.compositeRule&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >l?<span class="branch-0 cbranch-no" title="branch not covered" ></span>e.async?a+=" throw new ValidationError(["+B+"]); ":a+=" validate.errors = ["+B+"]; return false; ":</span>a+=" var err = "+B+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",u=L,l&amp;&amp;(a+=" break; ")}else <span class="missing-if-branch" title="else path not taken" >E</span>if(R)<span class="missing-if-branch" title="if path not taken" >I</span>if("failing"==O){<span class="cstat-no" title="statement not covered" >a+=" var "+h+" = errors;  ";v</span>ar V=<span class="cstat-no" title="statement not covered" >e.compositeRule;<span class="cstat-no" title="statement not covered" ></span>e.compositeRule=f.compositeRule=!0,f.schema=_,f.schemaPath=e.schemaPath+".additionalProperties",f.errSchemaPath=e.errSchemaPath+"/additionalProperties",f.errorPath=e.opts._errorDataPathProperty?e.errorPath:e.util.getPathExpr(e.errorPath,m,e.opts.jsonPointers);v</span>ar Q=<span class="cstat-no" title="statement not covered" >c+"["+m+"]";<span class="cstat-no" title="statement not covered" ></span>f.dataPathArr[y]=m;v</span>ar q=<span class="cstat-no" title="statement not covered" >e.validate(f);<span class="cstat-no" title="statement not covered" ></span>f.baseId=F,e.util.varOccurences(q,g)&lt;2?a+=" "+e.util.varReplace(q,g,Q)+" ":a+=" var "+g+" = "+Q+"; "+q+" ",a+=" if (!"+d+") { errors = "+h+"; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete "+c+"["+m+"]; }  ",e.compositeRule=f.compositeRule=V}</span>else{f.schema=_,f.schemaPath=e.schemaPath+".additionalProperties",f.errSchemaPath=e.errSchemaPath+"/additionalProperties",f.errorPath=e.opts._errorDataPathProperty?<span class="branch-0 cbranch-no" title="branch not covered" >e.errorPath:</span>e.util.getPathExpr(e.errorPath,m,e.opts.jsonPointers);Q=c+"["+m+"]";f.dataPathArr[y]=m;q=e.validate(f);f.baseId=F,e.util.varOccurences(q,g)&lt;2?a+=" "+e.util.varReplace(q,g,Q)+" ":a+=" var "+g+" = "+Q+"; "+q+" ",l&amp;&amp;(a+=" if (!"+d+") break; ")}e.errorPath=N}S&amp;&amp;(a+=" } "),a+=" }  ",l&amp;&amp;(a+=" if ("+d+") { ",p+="}")}var H=e.opts.useDefaults&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >!e.compositeRule;</span>if(E.length){var Y=E;<span class="missing-if-branch" title="else path not taken" >E</span>if(Y)for(var J,K=-1,W=Y.length-1;K&lt;W;){var Z=s[J=Y[K+=1]];if(e.util.schemaHasRules(Z,e.RULES.all)){var G=e.util.getProperty(J),X=(Q=c+G,H&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==Z.default)</span>;f.schema=Z,f.schemaPath=i+G,f.errSchemaPath=u+"/"+e.util.escapeFragment(J),f.errorPath=e.util.getPath(e.errorPath,J,e.opts.jsonPointers),f.dataPathArr[y]=e.util.toQuotedString(J);q=e.validate(f);if(f.baseId=F,e.util.varOccurences(q,g)&lt;2){q=e.util.varReplace(q,g,Q);var ee=Q}else{ee=g;a+=" var "+g+" = "+Q+"; "}<span class="missing-if-branch" title="if path not taken" >I</span>if(X)<span class="cstat-no" title="statement not covered" >a+=" "+q+" ";e</span>lse{if($&amp;&amp;$[J]){a+=" if ( "+ee+" === undefined ",A&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(J)+"') ")</span>,a+=") { "+d+" = false; ";N=e.errorPath,L=u;var re,te=e.util.escapeQuotes(J);e.opts._errorDataPathProperty&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.errorPath=e.util.getPath(N,J,e.opts.jsonPointers))</span>,u=e.errSchemaPath+"/required",(re=re||<span class="branch-1 cbranch-no" title="branch not covered" >[])</span>.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { missingProperty: '"+te+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: '",e.opts._errorDataPathProperty?<span class="branch-0 cbranch-no" title="branch not covered" >a+="is a required property":</span>a+="should have required property \\'"+te+"\\'",a+="' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" ")</span>,a+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >a+=" {} ";</span>B=a;a=re.pop(),!e.compositeRule&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >l?<span class="branch-0 cbranch-no" title="branch not covered" ></span>e.async?a+=" throw new ValidationError(["+B+"]); ":a+=" validate.errors = ["+B+"]; return false; ":</span>a+=" var err = "+B+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",u=L,e.errorPath=N,a+=" } else { "}else l?(a+=" if ( "+ee+" === undefined ",A&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(J)+"') ")</span>,a+=") { "+d+" = true; } else { "):(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" if ("+ee+" !== undefined ",A&amp;&amp;(a+=" &amp;&amp;   Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(J)+"') "),a+=" ) { ")</span>;a+=" "+q+" } "}}l&amp;&amp;(a+=" if ("+d+") { ",p+="}")}}<span class="missing-if-branch" title="if path not taken" >I</span>if(w.length){var ae=<span class="cstat-no" title="statement not covered" >w;<span class="cstat-no" title="statement not covered" ></span>if(ae)<span class="cstat-no" title="statement not covered" >for(var oe,ne=-1,se=ae.length-1;ne&lt;se;){<span class="cstat-no" title="statement not covered" >Z=b[oe=ae[ne+=1]];<span class="cstat-no" title="statement not covered" >i</span>f(e.util.schemaHasRules(Z,e.RULES.all)){<span class="cstat-no" title="statement not covered" >f.schema=Z,f.schemaPath=e.schemaPath+".patternProperties"+e.util.getProperty(oe),f.errSchemaPath=e.errSchemaPath+"/patternProperties/"+e.util.escapeFragment(oe),a+=A?" "+P+" = "+P+" || Object.keys("+c+"); for (var "+v+"=0; "+v+"&lt;"+P+".length; "+v+"++) { var "+m+" = "+P+"["+v+"]; ":" for (var "+m+" in "+c+") { ",a+=" if ("+e.usePattern(oe)+".test("+m+")) { ",f.errorPath=e.util.getPathExpr(e.errorPath,m,e.opts.jsonPointers);<span class="cstat-no" title="statement not covered" >Q</span>=c+"["+m+"]";<span class="cstat-no" title="statement not covered" >f</span>.dataPathArr[y]=m;<span class="cstat-no" title="statement not covered" >q</span>=e.validate(f);<span class="cstat-no" title="statement not covered" >f</span>.baseId=F,e.util.varOccurences(q,g)&lt;2?a+=" "+e.util.varReplace(q,g,Q)+" ":a+=" var "+g+" = "+Q+"; "+q+" ",l&amp;&amp;(a+=" if (!"+d+") break; "),a+=" } ",l&amp;&amp;(a+=" else "+d+" = true; "),a+=" }  ",l&amp;&amp;(a+=" if ("+d+") { ",p+="}")}</span>}</span>}</span></span>return l&amp;&amp;(a+=" "+p+" if ("+h+" == errors) {"),a=e.util.cleanUpCode(a)}},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a,o=<span class="cstat-no" title="statement not covered" >" ",</span>n=<span class="cstat-no" title="statement not covered" >e.level,</span>s=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>i=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>u=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>l=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>c=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>h=<span class="cstat-no" title="statement not covered" >"data"+(s||""),</span>f=<span class="cstat-no" title="statement not covered" >e.opts.$data&amp;&amp;i&amp;&amp;i.$data;<span class="cstat-no" title="statement not covered" ></span>f?(o+=" var schema"+n+" = "+e.util.getData(i.$data,s,e.dataPathArr)+"; ",a="schema"+n):a=i,o+="if ( ",f&amp;&amp;(o+=" ("+a+" !== undefined &amp;&amp; typeof "+a+" != 'string') || "),o+=" !"+(f?"(new RegExp("+a+"))":e.usePattern(i))+".test("+h+") ) {   ";v</span>ar p=<span class="cstat-no" title="statement not covered" >p||[];<span class="cstat-no" title="statement not covered" ></span>p.push(o),o="",!1!==e.createErrors?(o+=" { keyword: 'pattern' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { pattern:  ",o+=f?""+a:""+e.util.toQuotedString(i),o+="  } ",!1!==e.opts.messages&amp;&amp;(o+=" , message: 'should match pattern \"",o+=f?"' + "+a+" + '":""+e.util.escapeQuotes(i),o+="\"' "),e.opts.verbose&amp;&amp;(o+=" , schema:  ",o+=f?"validate.schema"+u:""+e.util.toQuotedString(i),o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),o+=" } "):o+=" {} ";v</span>ar d=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>return o=p.pop(),!e.compositeRule&amp;&amp;c?e.async?o+=" throw new ValidationError(["+d+"]); ":o+=" validate.errors = ["+d+"]; return false; ":o+=" var err = "+d+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&amp;&amp;(o+=" else { "),o}</span>},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >" ",</span>o=<span class="cstat-no" title="statement not covered" >e.level,</span>n=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>s=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>i=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>u=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>l=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>c=<span class="cstat-no" title="statement not covered" >"data"+(n||""),</span>h=<span class="cstat-no" title="statement not covered" >"valid"+o,</span>f=<span class="cstat-no" title="statement not covered" >"errs__"+o,</span>p=<span class="cstat-no" title="statement not covered" >e.util.copy(e),</span>d=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>p.level++;v</span>ar m=<span class="cstat-no" title="statement not covered" >"valid"+p.level,</span>v=<span class="cstat-no" title="statement not covered" >p.baseId,</span>y=<span class="cstat-no" title="statement not covered" >"prevValid"+o,</span>g=<span class="cstat-no" title="statement not covered" >"passingSchemas"+o;<span class="cstat-no" title="statement not covered" ></span>a+="var "+f+" = errors , "+y+" = false , "+h+" = false , "+g+" = null; ";v</span>ar P=<span class="cstat-no" title="statement not covered" >e.compositeRule;<span class="cstat-no" title="statement not covered" ></span>e.compositeRule=p.compositeRule=!0;v</span>ar E=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(E)<span class="cstat-no" title="statement not covered" >for(var b,w=-1,_=E.length-1;w&lt;_;)<span class="cstat-no" title="statement not covered" >b=E[w+=1],e.util.schemaHasRules(b,e.RULES.all)?(p.schema=b,p.schemaPath=i+"["+w+"]",p.errSchemaPath=u+"/"+w,a+="  "+e.validate(p)+" ",p.baseId=v):a+=" var "+m+" = true; ",w&amp;&amp;(a+=" if ("+m+" &amp;&amp; "+y+") { "+h+" = false; "+g+" = ["+g+", "+w+"]; } else { ",d+="}"),a+=" if ("+m+") { "+h+" = "+y+" = true; "+g+" = "+w+"; }";<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e.compositeRule=p.compositeRule=P,a+=d+"if (!"+h+") {   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'oneOf' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { passingSchemas: "+g+" } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should match exactly one schema in oneOf' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&amp;&amp;l&amp;&amp;(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),a+="} else {  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; }",e.opts.allErrors&amp;&amp;(a+=" } "),a}</span>},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >" ",</span>o=<span class="cstat-no" title="statement not covered" >e.level,</span>n=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>s=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>i=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>u=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>l=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>c=<span class="cstat-no" title="statement not covered" >"data"+(n||""),</span>h=<span class="cstat-no" title="statement not covered" >"errs__"+o,</span>f=<span class="cstat-no" title="statement not covered" >e.util.copy(e);<span class="cstat-no" title="statement not covered" ></span>f.level++;v</span>ar p=<span class="cstat-no" title="statement not covered" >"valid"+f.level;<span class="cstat-no" title="statement not covered" ></span>if(e.util.schemaHasRules(s,e.RULES.all)){<span class="cstat-no" title="statement not covered" >f.schema=s,f.schemaPath=i,f.errSchemaPath=u,a+=" var "+h+" = errors;  ";v</span>ar d,m=<span class="cstat-no" title="statement not covered" >e.compositeRule;<span class="cstat-no" title="statement not covered" ></span>e.compositeRule=f.compositeRule=!0,f.createErrors=!1,f.opts.allErrors&amp;&amp;(d=f.opts.allErrors,f.opts.allErrors=!1),a+=" "+e.validate(f)+" ",f.createErrors=!0,d&amp;&amp;(f.opts.allErrors=d),e.compositeRule=f.compositeRule=m,a+=" if ("+p+") {   ";v</span>ar v=<span class="cstat-no" title="statement not covered" >v||[];<span class="cstat-no" title="statement not covered" ></span>v.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'not' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: {} ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should NOT be valid' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";v</span>ar y=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>a=v.pop(),!e.compositeRule&amp;&amp;l?e.async?a+=" throw new ValidationError(["+y+"]); ":a+=" validate.errors = ["+y+"]; return false; ":a+=" var err = "+y+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else {  errors = "+h+"; if (vErrors !== null) { if ("+h+") vErrors.length = "+h+"; else vErrors = null; } ",e.opts.allErrors&amp;&amp;(a+=" } ")}</span>else <span class="cstat-no" title="statement not covered" >a+="  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'not' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: {} ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should NOT be valid' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",l&amp;&amp;(a+=" if (false) { ");<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a,o=<span class="cstat-no" title="statement not covered" >" ",</span>n=<span class="cstat-no" title="statement not covered" >e.level,</span>s=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>i=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>u=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>l=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>c=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>h=<span class="cstat-no" title="statement not covered" >"data"+(s||""),</span>f=<span class="cstat-no" title="statement not covered" >e.opts.$data&amp;&amp;i&amp;&amp;i.$data;<span class="cstat-no" title="statement not covered" ></span>f?(o+=" var schema"+n+" = "+e.util.getData(i.$data,s,e.dataPathArr)+"; ",a="schema"+n):a=i,o+="var division"+n+";if (",f&amp;&amp;(o+=" "+a+" !== undefined &amp;&amp; ( typeof "+a+" != 'number' || "),o+=" (division"+n+" = "+h+" / "+a+", ",e.opts.multipleOfPrecision?o+=" Math.abs(Math.round(division"+n+") - division"+n+") &gt; 1e-"+e.opts.multipleOfPrecision+" ":o+=" division"+n+" !== parseInt(division"+n+") ",o+=" ) ",f&amp;&amp;(o+="  )  "),o+=" ) {   ";v</span>ar p=<span class="cstat-no" title="statement not covered" >p||[];<span class="cstat-no" title="statement not covered" ></span>p.push(o),o="",!1!==e.createErrors?(o+=" { keyword: 'multipleOf' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { multipleOf: "+a+" } ",!1!==e.opts.messages&amp;&amp;(o+=" , message: 'should be multiple of ",o+=f?"' + "+a:a+"'"),e.opts.verbose&amp;&amp;(o+=" , schema:  ",o+=f?"validate.schema"+u:""+i,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),o+=" } "):o+=" {} ";v</span>ar d=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>return o=p.pop(),!e.compositeRule&amp;&amp;c?e.async?o+=" throw new ValidationError(["+d+"]); ":o+=" validate.errors = ["+d+"]; return false; ":o+=" var err = "+d+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&amp;&amp;(o+=" else { "),o}</span>},function(e,r,t){"use strict";e.exports=function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,s=e.schema[r],i=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,l=!e.opts.allErrors,c="data"+(n||""),h="valid"+o,f="errs__"+o,p=e.util.copy(e),d="";p.level++;var m="valid"+p.level,v="i"+o,y=p.dataLevel=e.dataLevel+1,g="data"+y,P=e.baseId;<span class="missing-if-branch" title="if path not taken" >I</span>if(a+="var "+f+" = errors;var "+h+";",Array.isArray(s)){var E=<span class="cstat-no" title="statement not covered" >e.schema.additionalItems;<span class="cstat-no" title="statement not covered" ></span>if(!1===E){<span class="cstat-no" title="statement not covered" >a+=" "+h+" = "+c+".length &lt;= "+s.length+"; ";v</span>ar b=<span class="cstat-no" title="statement not covered" >u;<span class="cstat-no" title="statement not covered" ></span>u=e.errSchemaPath+"/additionalItems",a+="  if (!"+h+") {   ";v</span>ar w=<span class="cstat-no" title="statement not covered" >w||[];<span class="cstat-no" title="statement not covered" ></span>w.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'additionalItems' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { limit: "+s.length+" } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should NOT have more than "+s.length+" items' "),e.opts.verbose&amp;&amp;(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";v</span>ar _=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>a=w.pop(),!e.compositeRule&amp;&amp;l?e.async?a+=" throw new ValidationError(["+_+"]); ":a+=" validate.errors = ["+_+"]; return false; ":a+=" var err = "+_+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",u=b,l&amp;&amp;(d+="}",a+=" else { ")}</span>v</span>ar S=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(S)<span class="cstat-no" title="statement not covered" >for(var x,R=-1,O=S.length-1;R&lt;O;)<span class="cstat-no" title="statement not covered" >if(x=S[R+=1],e.util.schemaHasRules(x,e.RULES.all)){<span class="cstat-no" title="statement not covered" >a+=" "+m+" = true; if ("+c+".length &gt; "+R+") { ";v</span>ar j=<span class="cstat-no" title="statement not covered" >c+"["+R+"]";<span class="cstat-no" title="statement not covered" ></span>p.schema=x,p.schemaPath=i+"["+R+"]",p.errSchemaPath=u+"/"+R,p.errorPath=e.util.getPathExpr(e.errorPath,R,e.opts.jsonPointers,!0),p.dataPathArr[y]=R;v</span>ar A=<span class="cstat-no" title="statement not covered" >e.validate(p);<span class="cstat-no" title="statement not covered" ></span>p.baseId=P,e.util.varOccurences(A,g)&lt;2?a+=" "+e.util.varReplace(A,g,j)+" ":a+=" var "+g+" = "+j+"; "+A+" ",a+=" }  ",l&amp;&amp;(a+=" if ("+m+") { ",d+="}")}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span>f("object"==typeof E&amp;&amp;e.util.schemaHasRules(E,e.RULES.all)){<span class="cstat-no" title="statement not covered" >p.schema=E,p.schemaPath=e.schemaPath+".additionalItems",p.errSchemaPath=e.errSchemaPath+"/additionalItems",a+=" "+m+" = true; if ("+c+".length &gt; "+s.length+") {  for (var "+v+" = "+s.length+"; "+v+" &lt; "+c+".length; "+v+"++) { ",p.errorPath=e.util.getPathExpr(e.errorPath,v,e.opts.jsonPointers,!0);<span class="cstat-no" title="statement not covered" >j</span>=c+"["+v+"]";<span class="cstat-no" title="statement not covered" >p</span>.dataPathArr[y]=v;<span class="cstat-no" title="statement not covered" >A</span>=e.validate(p);<span class="cstat-no" title="statement not covered" >p</span>.baseId=P,e.util.varOccurences(A,g)&lt;2?a+=" "+e.util.varReplace(A,g,j)+" ":a+=" var "+g+" = "+j+"; "+A+" ",l&amp;&amp;(a+=" if (!"+m+") break; "),a+=" } }  ",l&amp;&amp;(a+=" if ("+m+") { ",d+="}")}</span>}</span>else if(e.util.schemaHasRules(s,e.RULES.all)){p.schema=s,p.schemaPath=i,p.errSchemaPath=u,a+="  for (var "+v+" = 0; "+v+" &lt; "+c+".length; "+v+"++) { ",p.errorPath=e.util.getPathExpr(e.errorPath,v,e.opts.jsonPointers,!0);j=c+"["+v+"]";p.dataPathArr[y]=v;A=e.validate(p);p.baseId=P,e.util.varOccurences(A,g)&lt;2?a+=" "+e.util.varReplace(A,g,j)+" ":<span class="branch-1 cbranch-no" title="branch not covered" >a+=" var "+g+" = "+j+"; "+A+" ",</span>l&amp;&amp;(a+=" if (!"+m+") break; "),a+=" }"}return l&amp;&amp;(a+=" "+d+" if ("+f+" == errors) {"),a=e.util.cleanUpCode(a)}},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >" ",</span>o=<span class="cstat-no" title="statement not covered" >e.level,</span>n=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>s=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>i=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>u=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>l=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>c=<span class="cstat-no" title="statement not covered" >"data"+(n||""),</span>h=<span class="cstat-no" title="statement not covered" >"valid"+o,</span>f=<span class="cstat-no" title="statement not covered" >"errs__"+o,</span>p=<span class="cstat-no" title="statement not covered" >e.util.copy(e);<span class="cstat-no" title="statement not covered" ></span>p.level++;v</span>ar d=<span class="cstat-no" title="statement not covered" >"valid"+p.level,</span>m=<span class="cstat-no" title="statement not covered" >e.schema.then,</span>v=<span class="cstat-no" title="statement not covered" >e.schema.else,</span>y=<span class="cstat-no" title="statement not covered" >void 0!==m&amp;&amp;e.util.schemaHasRules(m,e.RULES.all),</span>g=<span class="cstat-no" title="statement not covered" >void 0!==v&amp;&amp;e.util.schemaHasRules(v,e.RULES.all),</span>P=<span class="cstat-no" title="statement not covered" >p.baseId;<span class="cstat-no" title="statement not covered" ></span>if(y||g){var E;<span class="cstat-no" title="statement not covered" >p.createErrors=!1,p.schema=s,p.schemaPath=i,p.errSchemaPath=u,a+=" var "+f+" = errors; var "+h+" = true;  ";v</span>ar b=<span class="cstat-no" title="statement not covered" >e.compositeRule;<span class="cstat-no" title="statement not covered" ></span>e.compositeRule=p.compositeRule=!0,a+="  "+e.validate(p)+" ",p.baseId=P,p.createErrors=!0,a+="  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; }  ",e.compositeRule=p.compositeRule=b,y?(a+=" if ("+d+") {  ",p.schema=e.schema.then,p.schemaPath=e.schemaPath+".then",p.errSchemaPath=e.errSchemaPath+"/then",a+="  "+e.validate(p)+" ",p.baseId=P,a+=" "+h+" = "+d+"; ",y&amp;&amp;g?a+=" var "+(E="ifClause"+o)+" = 'then'; ":E="'then'",a+=" } ",g&amp;&amp;(a+=" else { ")):a+=" if (!"+d+") { ",g&amp;&amp;(p.schema=e.schema.else,p.schemaPath=e.schemaPath+".else",p.errSchemaPath=e.errSchemaPath+"/else",a+="  "+e.validate(p)+" ",p.baseId=P,a+=" "+h+" = "+d+"; ",y&amp;&amp;g?a+=" var "+(E="ifClause"+o)+" = 'else'; ":E="'else'",a+=" } "),a+=" if (!"+h+") {   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'if' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { failingKeyword: "+E+" } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should match \"' + "+E+" + '\" schema' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&amp;&amp;l&amp;&amp;(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),a+=" }   ",l&amp;&amp;(a+=" else { "),a=e.util.cleanUpCode(a)}</span>else <span class="cstat-no" title="statement not covered" >l&amp;&amp;(a+=" if (true) { ");<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>},function(e,r,t){"use strict";e.exports=function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,s=e.schema[r],i=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,l=!e.opts.allErrors,c="data"+(n||<span class="branch-1 cbranch-no" title="branch not covered" >"")</span>;<span class="missing-if-branch" title="if path not taken" >I</span>if(!1===e.opts.format)<span class="cstat-no" title="statement not covered" >return l&amp;&amp;(a+=" if (true) { "),a;v</span>ar h,f=e.opts.$data&amp;&amp;s&amp;&amp;s.$data;f?(<span class="branch-0 cbranch-no" title="branch not covered" >a+=" var schema"+o+" = "+e.util.getData(s.$data,n,e.dataPathArr)+"; ",h="schema"+o)</span>:h=s;var p=e.opts.unknownFormats,d=Array.isArray(p);<span class="missing-if-branch" title="if path not taken" >I</span>if(f){<span class="cstat-no" title="statement not covered" >a+=" var "+(m="format"+o)+" = formats["+h+"]; var "+(v="isObject"+o)+" = typeof "+m+" == 'object' &amp;&amp; !("+m+" instanceof RegExp) &amp;&amp; "+m+".validate; var "+(y="formatType"+o)+" = "+v+" &amp;&amp; "+m+".type || 'string'; if ("+v+") { ",e.async&amp;&amp;(a+=" var async"+o+" = "+m+".async; "),a+=" "+m+" = "+m+".validate; } if (  ",f&amp;&amp;(a+=" ("+h+" !== undefined &amp;&amp; typeof "+h+" != 'string') || "),a+=" (","ignore"!=p&amp;&amp;(a+=" ("+h+" &amp;&amp; !"+m+" ",d&amp;&amp;(a+=" &amp;&amp; self._opts.unknownFormats.indexOf("+h+") == -1 "),a+=") || "),a+=" ("+m+" &amp;&amp; "+y+" == '"+t+"' &amp;&amp; !(typeof "+m+" == 'function' ? ",e.async?a+=" (async"+o+" ? await "+m+"("+c+") : "+m+"("+c+")) ":a+=" "+m+"("+c+") ",a+=" : "+m+".test("+c+"))))) {"}</span>else{var m;<span class="missing-if-branch" title="if path not taken" >I</span>if(!(m=e.formats[s])){<span class="cstat-no" title="statement not covered" >if("ignore"==p)<span class="cstat-no" title="statement not covered" >return e.logger.warn('unknown format "'+s+'" ignored in schema at path "'+e.errSchemaPath+'"'),l&amp;&amp;(a+=" if (true) { "),a;<span class="cstat-no" title="statement not covered" >i</span></span>f(d&amp;&amp;p.indexOf(s)&gt;=0)<span class="cstat-no" title="statement not covered" >return l&amp;&amp;(a+=" if (true) { "),a;<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error('unknown format "'+s+'" is used in schema at path "'+e.errSchemaPath+'"')}</span>var v,y=(v="object"==typeof m&amp;&amp;!(m instanceof RegExp)&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >m.validate)</span>&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >m.type|</span>|"string";<span class="missing-if-branch" title="if path not taken" >I</span>if(v){var g=<span class="cstat-no" title="statement not covered" >!0===m.async;<span class="cstat-no" title="statement not covered" ></span>m=m.validate}</span>if(y!=t)return l&amp;&amp;(a+=" if (true) { "),a;<span class="missing-if-branch" title="if path not taken" >I</span>if(g){<span class="cstat-no" title="statement not covered" >if(!e.async)<span class="cstat-no" title="statement not covered" >throw new Error("async format in sync schema");<span class="cstat-no" title="statement not covered" >a</span></span>+=" if (!(await "+(P="formats"+e.util.getProperty(s)+".validate")+"("+c+"))) { "}</span>else{a+=" if (! ";var P="formats"+e.util.getProperty(s);v&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >P+=".validate")</span>,a+="function"==typeof m?" "+P+"("+c+") ":" "+P+".test("+c+") ",a+=") { "}}var E=E||[];E.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'format' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { format:  ",a+=f?<span class="branch-0 cbranch-no" title="branch not covered" >""+h:</span>""+e.util.toQuotedString(s),a+="  } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should match format \"",a+=f?<span class="branch-0 cbranch-no" title="branch not covered" >"' + "+h+" + '":</span>""+e.util.escapeQuotes(s),a+="\"' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" , schema:  ",a+=f?"validate.schema"+i:""+e.util.toQuotedString(s),a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" ")</span>,a+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >a+=" {} ";</span>var b=a;return a=E.pop(),!e.compositeRule&amp;&amp;l?e.async?<span class="branch-0 cbranch-no" title="branch not covered" >a+=" throw new ValidationError(["+b+"]); ":</span>a+=" validate.errors = ["+b+"]; return false; ":a+=" var err = "+b+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",l&amp;&amp;(a+=" else { "),a}},function(e,r,t){"use strict";e.exports=function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,s=e.schema[r],i=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,l=!e.opts.allErrors,c="data"+(n||<span class="branch-1 cbranch-no" title="branch not covered" >"")</span>,h="valid"+o,f=e.opts.$data&amp;&amp;s&amp;&amp;s.$data;f&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" var schema"+o+" = "+e.util.getData(s.$data,n,e.dataPathArr)+"; ")</span>;var p="i"+o,d="schema"+o;f||(a+=" var "+d+" = validate.schema"+i+";"),a+="var "+h+";",f&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" if (schema"+o+" === undefined) "+h+" = true; else if (!Array.isArray(schema"+o+")) "+h+" = false; else {")</span>,a+=h+" = false;for (var "+p+"=0; "+p+"&lt;"+d+".length; "+p+"++) if (equal("+c+", "+d+"["+p+"])) { "+h+" = true; break; }",f&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+="  }  ")</span>,a+=" if (!"+h+") {   ";var m=m||[];m.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'enum' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { allowedValues: schema"+o+" } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should be equal to one of the allowed values' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" ")</span>,a+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >a+=" {} ";</span>var v=a;return a=m.pop(),!e.compositeRule&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >l?<span class="branch-0 cbranch-no" title="branch not covered" ></span>e.async?a+=" throw new ValidationError(["+v+"]); ":a+=" validate.errors = ["+v+"]; return false; ":</span>a+=" var err = "+v+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }",l&amp;&amp;(a+=" else { "),a}},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >" ",</span>o=<span class="cstat-no" title="statement not covered" >e.level,</span>n=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>s=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>i=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>u=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>l=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>c=<span class="cstat-no" title="statement not covered" >"data"+(n||""),</span>h=<span class="cstat-no" title="statement not covered" >"errs__"+o,</span>f=<span class="cstat-no" title="statement not covered" >e.util.copy(e),</span>p=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>f.level++;v</span>ar d=<span class="cstat-no" title="statement not covered" >"valid"+f.level,</span>m=<span class="cstat-no" title="statement not covered" >{},</span>v=<span class="cstat-no" title="statement not covered" >{},</span>y=<span class="cstat-no" title="statement not covered" >e.opts.ownProperties;<span class="cstat-no" title="statement not covered" ></span>for(b in s){var g=<span class="cstat-no" title="statement not covered" >s[b],</span>P=<span class="cstat-no" title="statement not covered" >Array.isArray(g)?v:m;<span class="cstat-no" title="statement not covered" ></span>P[b]=g}<span class="cstat-no" title="statement not covered" ></span>a</span>+="var "+h+" = errors;";v</span>ar E=<span class="cstat-no" title="statement not covered" >e.errorPath;<span class="cstat-no" title="statement not covered" ></span>for(var b in a+="var missing"+o+";",v)<span class="cstat-no" title="statement not covered" >if((P=v[b]).length){<span class="cstat-no" title="statement not covered" >if(a+=" if ( "+c+e.util.getProperty(b)+" !== undefined ",y&amp;&amp;(a+=" &amp;&amp; Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(b)+"') "),l){<span class="cstat-no" title="statement not covered" >a+=" &amp;&amp; ( ";v</span>ar w=<span class="cstat-no" title="statement not covered" >P;<span class="cstat-no" title="statement not covered" ></span>if(w)<span class="cstat-no" title="statement not covered" >for(var _=-1,S=w.length-1;_&lt;S;){<span class="cstat-no" title="statement not covered" >F=w[_+=1],_&amp;&amp;(a+=" || "),a+=" ( ( "+(I=c+(k=e.util.getProperty(F)))+" === undefined ",y&amp;&amp;(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(F)+"') "),a+=") &amp;&amp; (missing"+o+" = "+e.util.toQuotedString(e.opts.jsonPointers?F:k)+") ) "}<span class="cstat-no" title="statement not covered" ></span>a</span></span>+=")) {  ";v</span>ar x=<span class="cstat-no" title="statement not covered" >"missing"+o,</span>R=<span class="cstat-no" title="statement not covered" >"' + "+x+" + '";<span class="cstat-no" title="statement not covered" ></span>e.opts._errorDataPathProperty&amp;&amp;(e.errorPath=e.opts.jsonPointers?e.util.getPathExpr(E,x,!0):E+" + "+x);v</span>ar O=<span class="cstat-no" title="statement not covered" >O||[];<span class="cstat-no" title="statement not covered" ></span>O.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { property: '"+e.util.escapeQuotes(b)+"', missingProperty: '"+R+"', depsCount: "+P.length+", deps: '"+e.util.escapeQuotes(1==P.length?P[0]:P.join(", "))+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should have ",1==P.length?a+="property "+e.util.escapeQuotes(P[0]):a+="properties "+e.util.escapeQuotes(P.join(", ")),a+=" when property "+e.util.escapeQuotes(b)+" is present' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";v</span>ar j=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>a=O.pop(),!e.compositeRule&amp;&amp;l?e.async?a+=" throw new ValidationError(["+j+"]); ":a+=" validate.errors = ["+j+"]; return false; ":a+=" var err = "+j+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}</span>else{<span class="cstat-no" title="statement not covered" >a+=" ) { ";v</span>ar A=<span class="cstat-no" title="statement not covered" >P;<span class="cstat-no" title="statement not covered" ></span>if(A)<span class="cstat-no" title="statement not covered" >for(var F,D=-1,$=A.length-1;D&lt;$;){<span class="cstat-no" title="statement not covered" >F=A[D+=1];v</span>ar k=<span class="cstat-no" title="statement not covered" >e.util.getProperty(F),</span>I=(<span class="cstat-no" title="statement not covered" >R=e.util.escapeQuotes(F),c+k)</span>;<span class="cstat-no" title="statement not covered" >e.opts._errorDataPathProperty&amp;&amp;(e.errorPath=e.util.getPath(E,F,e.opts.jsonPointers)),a+=" if ( "+I+" === undefined ",y&amp;&amp;(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(F)+"') "),a+=") {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { property: '"+e.util.escapeQuotes(b)+"', missingProperty: '"+R+"', depsCount: "+P.length+", deps: '"+e.util.escapeQuotes(1==P.length?P[0]:P.join(", "))+"' } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should have ",1==P.length?a+="property "+e.util.escapeQuotes(P[0]):a+="properties "+e.util.escapeQuotes(P.join(", ")),a+=" when property "+e.util.escapeQuotes(b)+" is present' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "}</span>}<span class="cstat-no" title="statement not covered" ></span></span>a</span>+=" }   ",l&amp;&amp;(p+="}",a+=" else { ")}<span class="cstat-no" title="statement not covered" ></span>e</span></span>.errorPath=E;v</span>ar C=<span class="cstat-no" title="statement not covered" >f.baseId;<span class="cstat-no" title="statement not covered" ></span>for(var b in m){<span class="cstat-no" title="statement not covered" >g=m[b];<span class="cstat-no" title="statement not covered" >e</span>.util.schemaHasRules(g,e.RULES.all)&amp;&amp;(a+=" "+d+" = true; if ( "+c+e.util.getProperty(b)+" !== undefined ",y&amp;&amp;(a+=" &amp;&amp; Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(b)+"') "),a+=") { ",f.schema=g,f.schemaPath=i+e.util.getProperty(b),f.errSchemaPath=u+"/"+e.util.escapeFragment(b),a+="  "+e.validate(f)+" ",f.baseId=C,a+=" }  ",l&amp;&amp;(a+=" if ("+d+") { ",p+="}"))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l&amp;&amp;(a+="   "+p+" if ("+h+" == errors) {"),a=e.util.cleanUpCode(a)}</span>},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >" ",</span>o=<span class="cstat-no" title="statement not covered" >e.level,</span>n=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>s=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>i=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>u=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>l=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>c=<span class="cstat-no" title="statement not covered" >"data"+(n||""),</span>h=<span class="cstat-no" title="statement not covered" >"valid"+o,</span>f=<span class="cstat-no" title="statement not covered" >"errs__"+o,</span>p=<span class="cstat-no" title="statement not covered" >e.util.copy(e);<span class="cstat-no" title="statement not covered" ></span>p.level++;v</span>ar d=<span class="cstat-no" title="statement not covered" >"valid"+p.level,</span>m=<span class="cstat-no" title="statement not covered" >"i"+o,</span>v=<span class="cstat-no" title="statement not covered" >p.dataLevel=e.dataLevel+1,</span>y=<span class="cstat-no" title="statement not covered" >"data"+v,</span>g=<span class="cstat-no" title="statement not covered" >e.baseId,</span>P=<span class="cstat-no" title="statement not covered" >e.util.schemaHasRules(s,e.RULES.all);<span class="cstat-no" title="statement not covered" ></span>if(a+="var "+f+" = errors;var "+h+";",P){var E=<span class="cstat-no" title="statement not covered" >e.compositeRule;<span class="cstat-no" title="statement not covered" ></span>e.compositeRule=p.compositeRule=!0,p.schema=s,p.schemaPath=i,p.errSchemaPath=u,a+=" var "+d+" = false; for (var "+m+" = 0; "+m+" &lt; "+c+".length; "+m+"++) { ",p.errorPath=e.util.getPathExpr(e.errorPath,m,e.opts.jsonPointers,!0);v</span>ar b=<span class="cstat-no" title="statement not covered" >c+"["+m+"]";<span class="cstat-no" title="statement not covered" ></span>p.dataPathArr[v]=m;v</span>ar w=<span class="cstat-no" title="statement not covered" >e.validate(p);<span class="cstat-no" title="statement not covered" ></span>p.baseId=g,e.util.varOccurences(w,y)&lt;2?a+=" "+e.util.varReplace(w,y,b)+" ":a+=" var "+y+" = "+b+"; "+w+" ",a+=" if ("+d+") break; }  ",e.compositeRule=p.compositeRule=E,a+="  if (!"+d+") {"}</span>else <span class="cstat-no" title="statement not covered" >a+=" if ("+c+".length == 0) {";v</span></span>ar _=<span class="cstat-no" title="statement not covered" >_||[];<span class="cstat-no" title="statement not covered" ></span>_.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'contains' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: {} ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should contain a valid item' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";v</span>ar S=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>return a=_.pop(),!e.compositeRule&amp;&amp;l?e.async?a+=" throw new ValidationError(["+S+"]); ":a+=" validate.errors = ["+S+"]; return false; ":a+=" var err = "+S+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { ",P&amp;&amp;(a+="  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; } "),e.opts.allErrors&amp;&amp;(a+=" } "),a=e.util.cleanUpCode(a)}</span>},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >" ",</span>o=<span class="cstat-no" title="statement not covered" >e.level,</span>n=<span class="cstat-no" title="statement not covered" >e.dataLevel,</span>s=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>i=<span class="cstat-no" title="statement not covered" >e.schemaPath+e.util.getProperty(r),</span>u=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>l=<span class="cstat-no" title="statement not covered" >!e.opts.allErrors,</span>c=<span class="cstat-no" title="statement not covered" >"data"+(n||""),</span>h=<span class="cstat-no" title="statement not covered" >"valid"+o,</span>f=<span class="cstat-no" title="statement not covered" >e.opts.$data&amp;&amp;s&amp;&amp;s.$data;<span class="cstat-no" title="statement not covered" ></span>f&amp;&amp;(a+=" var schema"+o+" = "+e.util.getData(s.$data,n,e.dataPathArr)+"; "),f||(a+=" var schema"+o+" = validate.schema"+i+";"),a+="var "+h+" = equal("+c+", schema"+o+"); if (!"+h+") {   ";v</span>ar p=<span class="cstat-no" title="statement not covered" >p||[];<span class="cstat-no" title="statement not covered" ></span>p.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'const' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { allowedValue: schema"+o+" } ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should be equal to constant' "),e.opts.verbose&amp;&amp;(a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";v</span>ar d=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>return a=p.pop(),!e.compositeRule&amp;&amp;l?e.async?a+=" throw new ValidationError(["+d+"]); ":a+=" validate.errors = ["+d+"]; return false; ":a+=" var err = "+d+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }",l&amp;&amp;(a+=" else { "),a}</span>},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >" ",</span>o=<span class="cstat-no" title="statement not covered" >e.schema[r],</span>n=<span class="cstat-no" title="statement not covered" >e.errSchemaPath+"/"+r,</span>s=(<span class="cstat-no" title="statement not covered" >e.opts.allErrors,e.util.toQuotedString(o))</span>;<span class="cstat-no" title="statement not covered" >return!0===e.opts.$comment?a+=" console.log("+s+");":"function"==typeof e.opts.$comment&amp;&amp;(a+=" self._opts.$comment("+s+", "+e.util.toQuotedString(n)+", validate.root.schema);"),a}</span>},function(e,r,t){"use strict";e.exports=function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,s=e.schema[r],i=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,l=!e.opts.allErrors,c="data"+(n||<span class="branch-1 cbranch-no" title="branch not covered" >"")</span>,h="valid"+o,f="errs__"+o,p=e.util.copy(e),d="";p.level++;var m="valid"+p.level;if(s.every(function(r){return e.util.schemaHasRules(r,e.RULES.all)})){var v=p.baseId;a+=" var "+f+" = errors; var "+h+" = false;  ";var y=e.compositeRule;e.compositeRule=p.compositeRule=!0;var g=s;<span class="missing-if-branch" title="else path not taken" >E</span>if(g)for(var P,E=-1,b=g.length-1;E&lt;b;)P=g[E+=1],p.schema=P,p.schemaPath=i+"["+E+"]",p.errSchemaPath=u+"/"+E,a+="  "+e.validate(p)+" ",p.baseId=v,a+=" "+h+" = "+h+" || "+m+"; if (!"+h+") { ",d+="}";e.compositeRule=p.compositeRule=y,a+=" "+d+" if (!"+h+") {   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'anyOf' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: {} ",!1!==e.opts.messages&amp;&amp;(a+=" , message: 'should match some schema in anyOf' "),e.opts.verbose&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" , schema: validate.schema"+i+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" ")</span>,a+=" } "):<span class="branch-1 cbranch-no" title="branch not covered" >a+=" {} ",</span>a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&amp;&amp;l&amp;&amp;(e.async?<span class="branch-0 cbranch-no" title="branch not covered" >a+=" throw new ValidationError(vErrors); ":</span>a+=" validate.errors = vErrors; return false; "),a+=" } else {  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; } ",e.opts.allErrors&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a+=" } ")</span>,a=e.util.cleanUpCode(a)}else l&amp;&amp;(a+=" if (true) { ");return a}},function(e,r,t){"use strict";e.exports=function(e,r,t){var a=" ",o=e.schema[r],n=e.schemaPath+e.util.getProperty(r),s=e.errSchemaPath+"/"+r,i=!e.opts.allErrors,u=e.util.copy(e),l="";u.level++;var c="valid"+u.level,h=u.baseId,f=!0,p=o;<span class="missing-if-branch" title="else path not taken" >E</span>if(p)for(var d,m=-1,v=p.length-1;m&lt;v;)d=p[m+=1],e.util.schemaHasRules(d,e.RULES.all)&amp;&amp;(f=!1,u.schema=d,u.schemaPath=n+"["+m+"]",u.errSchemaPath=s+"/"+m,a+="  "+e.validate(u)+" ",u.baseId=h,i&amp;&amp;(a+=" if ("+c+") { ",l+="}"));return i&amp;&amp;(a+=f?<span class="branch-0 cbranch-no" title="branch not covered" >" if (true) { ":</span>" "+l.slice(0,-1)+" "),a=e.util.cleanUpCode(a)}},function(e,r,t){"use strict";e.exports=function(e,r,t){var a,o,n=" ",s=e.level,i=e.dataLevel,u=e.schema[r],l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(i||""),f="valid"+s;if("#"==u||"#/"==u)e.isRoot?(a=e.async,o="validate"):(a=!0===e.root.schema.$async,o="root.refVal[0]");else{var p=e.resolveRef(e.baseId,u,e.isRoot);<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0===p){var d=<span class="cstat-no" title="statement not covered" >e.MissingRefError.message(e.baseId,u);<span class="cstat-no" title="statement not covered" ></span>if("fail"==e.opts.missingRefs){<span class="cstat-no" title="statement not covered" >e.logger.error(d),(g=g||[]).push(n),n="",!1!==e.createErrors?(n+=" { keyword: '$ref' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { ref: '"+e.util.escapeQuotes(u)+"' } ",!1!==e.opts.messages&amp;&amp;(n+=" , message: 'can\\'t resolve reference "+e.util.escapeQuotes(u)+"' "),e.opts.verbose&amp;&amp;(n+=" , schema: "+e.util.toQuotedString(u)+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),n+=" } "):n+=" {} ";v</span>ar m=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>n=g.pop(),!e.compositeRule&amp;&amp;c?e.async?n+=" throw new ValidationError(["+m+"]); ":n+=" validate.errors = ["+m+"]; return false; ":n+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",c&amp;&amp;(n+=" if (false) { ")}</span>else{<span class="cstat-no" title="statement not covered" >if("ignore"!=e.opts.missingRefs)<span class="cstat-no" title="statement not covered" >throw new e.MissingRefError(e.baseId,u,d);<span class="cstat-no" title="statement not covered" >e</span></span>.logger.warn(d),c&amp;&amp;(n+=" if (true) { ")}</span>}</span>else if(p.inline){var v=e.util.copy(e);v.level++;var y="valid"+v.level;v.schema=p.schema,v.schemaPath="",v.errSchemaPath=u,n+=" "+e.validate(v).replace(/validate\.schema/g,p.code)+" ",c&amp;&amp;(n+=" if ("+y+") { ")}else a=!0===p.$async||e.async&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >!1!==p.$async,</span>o=p.code}if(o){var g;(g=g||[]).push(n),n="",e.opts.passContext?<span class="branch-0 cbranch-no" title="branch not covered" >n+=" "+o+".call(this, ":</span>n+=" "+o+"( ",n+=" "+h+", (dataPath || '')",'""'!=e.errorPath&amp;&amp;(n+=" + "+e.errorPath);var P=n+=" , "+(i?"data"+(i-1||""):<span class="branch-1 cbranch-no" title="branch not covered" >"parentData")</span>+" , "+(i?e.dataPathArr[i]:<span class="branch-1 cbranch-no" title="branch not covered" >"parentDataProperty")</span>+", rootData)  ";<span class="missing-if-branch" title="if path not taken" >I</span>if(n=g.pop(),a){<span class="cstat-no" title="statement not covered" >if(!e.async)<span class="cstat-no" title="statement not covered" >throw new Error("async schema referenced by sync schema");<span class="cstat-no" title="statement not covered" >c</span></span>&amp;&amp;(n+=" var "+f+"; "),n+=" try { await "+P+"; ",c&amp;&amp;(n+=" "+f+" = true; "),n+=" } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ",c&amp;&amp;(n+=" "+f+" = false; "),n+=" } ",c&amp;&amp;(n+=" if ("+f+") { ")}</span>else n+=" if (!"+P+") { if (vErrors === null) vErrors = "+o+".errors; else vErrors = vErrors.concat("+o+".errors); errors = vErrors.length; } ",c&amp;&amp;(n+=" else { ")}return n}},function(e,r,t){"use strict";e.exports={$ref:t(46),allOf:t(45),anyOf:t(44),$comment:t(43),const:t(42),contains:t(41),dependencies:t(40),enum:t(39),format:t(38),if:t(37),items:t(36),maximum:t(12),minimum:t(12),maxItems:t(11),minItems:t(11),maxLength:t(10),minLength:t(10),maxProperties:t(9),minProperties:t(9),multipleOf:t(35),not:t(34),oneOf:t(33),pattern:t(32),properties:t(31),propertyNames:t(30),required:t(29),uniqueItems:t(28),validate:t(13)}},function(e,r,t){"use strict";var a=t(47),o=t(2).toHash;e.exports=function(){var e=[{type:"number",rules:[{maximum:["exclusiveMaximum"]},{minimum:["exclusiveMinimum"]},"multipleOf","format"]},{type:"string",rules:["maxLength","minLength","pattern","format"]},{type:"array",rules:["maxItems","minItems","items","contains","uniqueItems"]},{type:"object",rules:["maxProperties","minProperties","required","dependencies","propertyNames",{properties:["additionalProperties","patternProperties"]}]},{rules:["$ref","const","enum","not","anyOf","oneOf","allOf","if"]}],r=["type","$comment"];return e.all=o(r),e.types=o(["number","integer","string","array","object","boolean","null"]),e.forEach(function(t){t.rules=t.rules.map(function(t){var o;if("object"==typeof t){var n=Object.keys(t)[0];o=t[n],t=n,o.forEach(function(t){r.push(t),e.all[t]=!0})}return r.push(t),e.all[t]={keyword:t,code:a[t],implements:o}}),e.all.$comment={keyword:"$comment",code:a.$comment},t.type&amp;&amp;(e.types[t.type]=t)}),e.keywords=o(r.concat(["$schema","$id","id","$data","title","description","default","definitions","examples","readOnly","writeOnly","contentMediaType","contentEncoding","additionalItems","then","else"])),e.custom={},e}},function(e,r,t){"use strict";var a=t(2),o=/^(\d\d\d\d)-(\d\d)-(\d\d)$/,n=[0,31,28,31,30,31,30,31,31,30,31,30,31],s=/^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i,i=/^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i,u=/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&amp;'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&amp;'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&amp;'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&amp;'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&amp;'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,l=/^(?:(?:[^\x00-\x20"'&lt;&gt;%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&amp;=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,c=/^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,h=/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,f=/^(?:\/(?:[^~/]|~0|~1)*)*$/,p=/^#(?:\/(?:[a-z0-9_\-.!$&amp;'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,d=/^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;function m(e){return e="full"==e?<span class="branch-0 cbranch-no" title="branch not covered" >"full":</span>"fast",a.copy(m[e])}function <span class="fstat-no" title="function not covered" >v(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.match(o);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >+r[1],</span>a=<span class="cstat-no" title="statement not covered" >+r[2],</span>s=<span class="cstat-no" title="statement not covered" >+r[3];<span class="cstat-no" title="statement not covered" ></span>return a&gt;=1&amp;&amp;a&lt;=12&amp;&amp;s&gt;=1&amp;&amp;s&lt;=(2==a&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e%4==0&amp;&amp;(e%100!=0||e%400==0)}</span>(t)?29:n[a])}</span>function <span class="fstat-no" title="function not covered" >y(</span>e,r){var t=<span class="cstat-no" title="statement not covered" >e.match(s);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >t[1],</span>o=<span class="cstat-no" title="statement not covered" >t[2],</span>n=<span class="cstat-no" title="statement not covered" >t[3],</span>i=<span class="cstat-no" title="statement not covered" >t[5];<span class="cstat-no" title="statement not covered" ></span>return(a&lt;=23&amp;&amp;o&lt;=59&amp;&amp;n&lt;=59||23==a&amp;&amp;59==o&amp;&amp;60==n)&amp;&amp;(!r||i)}</span>e.exports=m,m.fast={date:/^\d\d\d\d-[0-1]\d-[0-3]\d$/,time:/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,"date-time":/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,uri:/^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,"uri-reference":/^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,"uri-template":l,url:c,email:/^[a-z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,hostname:i,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:b,uuid:h,"json-pointer":f,"json-pointer-uri-fragment":p,"relative-json-pointer":d},m.full={date:v,time:y,"date-time":<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.split(g);<span class="cstat-no" title="statement not covered" ></span>return 2==r.length&amp;&amp;v(r[0])&amp;&amp;y(r[1],!0)}</span>,uri:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return P.test(e)&amp;&amp;u.test(e)}</span>,"uri-reference":/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&amp;'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&amp;'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&amp;'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&amp;'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&amp;'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&amp;'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&amp;'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&amp;'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&amp;'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-template":l,url:c,email:/^[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;''*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,hostname:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.length&lt;=255&amp;&amp;i.test(e)}</span>,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:b,uuid:h,"json-pointer":f,"json-pointer-uri-fragment":p,"relative-json-pointer":d};var g=/t|\s/i;var P=/\/|:/;var E=/[^\\]\\Z/;function <span class="fstat-no" title="function not covered" >b(</span>e){<span class="cstat-no" title="statement not covered" >if(E.test(e))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return new RegExp(e),!0}</span>catch(e){<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>},function(e,r,t){"use strict";var a=e.exports=function(){this._cache={}};a.prototype.put=function(e,r){this._cache[e]=r},a.prototype.get=function(e){return this._cache[e]},a.prototype.del=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >delete this._cache[e]}</span>,a.prototype.clear=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this._cache={}}</span>},function(e,r,t){"use strict";var a=e.exports=function(e,r,t){"function"==typeof r&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t=r,r={})</span>,function e(r,t,o,n,s,i,u,l,c){if(o&amp;&amp;"object"==typeof o&amp;&amp;!Array.isArray(o))for(var h in t(o,n,s,i,u,l,c),o){var f=o[h];if(Array.isArray(f)){if(h in a.arrayKeywords)for(var p=0;p&lt;f.length;p++)e(r,t,f[p],n+"/"+h+"/"+p,s,n,h,o,p)}else if(h in a.propsKeywords){<span class="missing-if-branch" title="else path not taken" >E</span>if(f&amp;&amp;"object"==typeof f)for(var d in f)e(r,t,f[d],n+"/"+h+"/"+d.replace(/~/g,"~0").replace(/\//g,"~1"),s,n,h,o,d)}else(h in a.keywords||r.allKeys&amp;&amp;!(h in a.skipKeywords))&amp;&amp;e(r,t,f,n+"/"+h,s,n,h,o)}}(r,t,e,"",e)};a.keywords={additionalItems:!0,items:!0,contains:!0,additionalProperties:!0,propertyNames:!0,not:!0},a.arrayKeywords={items:!0,allOf:!0,anyOf:!0,oneOf:!0},a.propsKeywords={definitions:!0,properties:!0,patternProperties:!0,dependencies:!0},a.skipKeywords={enum:!0,const:!0,required:!0,maximum:!0,minimum:!0,exclusiveMaximum:!0,exclusiveMinimum:!0,multipleOf:!0,maxLength:!0,minLength:!0,pattern:!0,format:!0,maxItems:!0,minItems:!0,uniqueItems:!0,maxProperties:!0,minProperties:!0}},function(e,r,t){"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r,t=0,a=e.length,o=0;o&lt;a;)<span class="cstat-no" title="statement not covered" >t++,(r=e.charCodeAt(o++))&gt;=55296&amp;&amp;r&lt;=56319&amp;&amp;o&lt;a&amp;&amp;56320==(64512&amp;(r=e.charCodeAt(o)))&amp;&amp;o++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>},function(e,r){var t;t=function(){return this}();try{t=t||<span class="branch-1 cbranch-no" title="branch not covered" >Function("return this")()|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >(0,eval)("this")}</span>catch(e){<span class="cstat-no" title="statement not covered" >"object"==typeof window&amp;&amp;(t=window)}</span>e.exports=t},function(e,r){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=<span class="fstat-no" title="function not covered" >fu</span>nction(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.l}</span>}),Object.defineProperty(e,"id",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.i}</span>}),e.webpackPolyfill=1),e}},function(e,r,t){"use strict";var a=t(5),o=t(2),n=t(3),s=t(14),i=t(13),u=o.ucs2length,l=t(4),c=n.Validation;function h(e,r,t){for(var a=0;a&lt;this._compilations.length;a++){var o=this._compilations[a];<span class="missing-if-branch" title="else path not taken" >E</span>if(o.schema==e&amp;&amp;o.root==r&amp;&amp;o.baseId==t)return a}return-1}function <span class="fstat-no" title="function not covered" >f(</span>e,r){<span class="cstat-no" title="statement not covered" >return"var pattern"+e+" = new RegExp("+o.toQuotedString(r[e])+");"}</span>function <span class="fstat-no" title="function not covered" >p(</span>e){<span class="cstat-no" title="statement not covered" >return"var default"+e+" = defaults["+e+"];"}</span>function d(e,r){return void 0===r[e]?"":"var refVal"+e+" = refVal["+e+"];"}function <span class="fstat-no" title="function not covered" >m(</span>e){<span class="cstat-no" title="statement not covered" >return"var customRule"+e+" = customRules["+e+"];"}</span>function v(e,r){if(!e.length)return"";for(var t="",a=0;a&lt;e.length;a++)t+=r(a,e);return t}e.exports=function e(r,t,y,g){var P=this,E=this._opts,b=[void 0],w={},_=[],S={},x=[],R={},O=[];t=t||{schema:r,refVal:b,refs:w};var j=function(e,r,t){var a=h.call(this,e,r,t);return a&gt;=0?<span class="branch-0 cbranch-no" title="branch not covered" >{index:a,compiling:!0}:</span>(a=this._compilations.length,this._compilations[a]={schema:e,root:r,baseId:t},{index:a,compiling:!1})}.call(this,r,t,g);var A=this._compilations[j.index];<span class="missing-if-branch" title="if path not taken" >I</span>if(j.compiling)<span class="cstat-no" title="statement not covered" >return A.callValidate=function <span class="fstat-no" title="function not covered" >e(</span>){var r=<span class="cstat-no" title="statement not covered" >A.validate;</span>var t=<span class="cstat-no" title="statement not covered" >r.apply(null,arguments);<span class="cstat-no" title="statement not covered" ></span>e.errors=r.errors;<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>;v</span>ar F=this._formats;var D=this.RULES;try{var $=I(r,t,y,g);A.validate=$;var k=A.callValidate;return k&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >k.schema=$.schema,k.errors=null,k.refs=$.refs,k.refVal=$.refVal,k.root=$.root,k.$async=$.$async,E.sourceCode&amp;&amp;(k.source=$.source))</span>,$}finally{(function(e,r,t){var a=h.call(this,e,r,t);a&gt;=0&amp;&amp;this._compilations.splice(a,1)}).call(this,r,t,g)}function I(r,s,h,y){var g=!s||s&amp;&amp;s.schema==r;<span class="missing-if-branch" title="if path not taken" >I</span>if(s.schema!=t.schema)<span class="cstat-no" title="statement not covered" >return e.call(P,r,s,h,y);v</span>ar S,R=!0===r.$async,j=i({isTop:!0,schema:r,isRoot:g,baseId:y,root:s,schemaPath:"",errSchemaPath:"#",errorPath:'""',MissingRefError:n.MissingRef,RULES:D,validate:i,util:o,resolve:a,resolveRef:C,usePattern:U,useDefault:N,useCustomRule:z,opts:E,formats:F,logger:P.logger,self:P});j=v(b,d)+v(_,f)+v(x,p)+v(O,m)+j,E.processCode&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >j=E.processCode(j))</span>;try{var A=new Function("self","RULES","formats","root","refVal","defaults","customRules","equal","ucs2length","ValidationError",j);S=A(P,D,F,t,b,x,O,l,u,c),b[0]=S}catch(e){<span class="cstat-no" title="statement not covered" >throw P.logger.error("Error compiling schema, function code:",j),e}</span>return S.schema=r,S.errors=null,S.refs=w,S.refVal=b,S.root=g?S:s,R&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >S.$async=!0)</span>,!0===E.sourceCode&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >S.source={code:j,patterns:_,defaults:x})</span>,S}function C(r,o,n){o=a.url(r,o);var s,i,u=w[o];if(void 0!==u)return M(s=b[u],i="refVal["+u+"]");<span class="missing-if-branch" title="if path not taken" >I</span>if(!n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t.refs)</span>{var l=<span class="cstat-no" title="statement not covered" >t.refs[o];<span class="cstat-no" title="statement not covered" ></span>if(void 0!==l)<span class="cstat-no" title="statement not covered" >return s=t.refVal[l],i=T(o,s),M(s,i)}</span></span>i=T(o);var c=a.call(P,I,t,o);<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0===c){var h=<span class="cstat-no" title="statement not covered" >y&amp;&amp;y[o];<span class="cstat-no" title="statement not covered" ></span>h&amp;&amp;(c=a.inlineRef(h,E.inlineRefs)?h:e.call(P,h,t,y,r))}<span class="missing-if-branch" title="else path not taken" >E</span></span>if(void 0!==c)return function(e,r){var t=w[e];b[t]=r}(o,c),M(c,i);<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >delete w[e]}</span>(o)}</span>function T(e,r){var t=b.length;return b[t]=r,w[e]=t,"refVal"+t}function M(e,r){return"object"==typeof e||"boolean"==typeof e?{code:r,schema:e,inline:!0}:{code:r,$async:e&amp;&amp;!!e.$async}}function <span class="fstat-no" title="function not covered" >U(</span>e){var r=<span class="cstat-no" title="statement not covered" >S[e];<span class="cstat-no" title="statement not covered" ></span>return void 0===r&amp;&amp;(r=S[e]=_.length,_[r]=e),"pattern"+r}</span>function <span class="fstat-no" title="function not covered" >N(</span>e){<span class="cstat-no" title="statement not covered" >switch(typeof e){case"boolean":case"number":<span class="cstat-no" title="statement not covered" >return""+e;c</span>ase"string":<span class="cstat-no" title="statement not covered" >return o.toQuotedString(e);c</span>ase"object":<span class="cstat-no" title="statement not covered" >if(null===e)<span class="cstat-no" title="statement not covered" >return"null";v</span></span>ar r=<span class="cstat-no" title="statement not covered" >s(e),</span>t=<span class="cstat-no" title="statement not covered" >R[r];<span class="cstat-no" title="statement not covered" ></span>return void 0===t&amp;&amp;(t=R[r]=x.length,x[t]=e),"default"+t}</span>}</span>function <span class="fstat-no" title="function not covered" >z(</span>e,r,t,a){var o=<span class="cstat-no" title="statement not covered" >e.definition.validateSchema;<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;!1!==P._opts.validateSchema){var n=<span class="cstat-no" title="statement not covered" >o(r);<span class="cstat-no" title="statement not covered" ></span>if(!n){var s=<span class="cstat-no" title="statement not covered" >"keyword schema is invalid: "+P.errorsText(o.errors);<span class="cstat-no" title="statement not covered" ></span>if("log"!=P._opts.validateSchema)<span class="cstat-no" title="statement not covered" >throw new Error(s);<span class="cstat-no" title="statement not covered" >P</span></span>.logger.error(s)}</span>}</span>v</span>ar i,u=<span class="cstat-no" title="statement not covered" >e.definition.compile,</span>l=<span class="cstat-no" title="statement not covered" >e.definition.inline,</span>c=<span class="cstat-no" title="statement not covered" >e.definition.macro;<span class="cstat-no" title="statement not covered" ></span>if(u)<span class="cstat-no" title="statement not covered" >i=u.call(P,r,t,a);e</span>lse <span class="cstat-no" title="statement not covered" >if(c)<span class="cstat-no" title="statement not covered" >i=c.call(P,r,t,a),!1!==E.validateSchema&amp;&amp;P.validateSchema(i,!0);e</span>lse <span class="cstat-no" title="statement not covered" >if(l)<span class="cstat-no" title="statement not covered" >i=l.call(P,a,e.keyword,r,t);e</span>lse <span class="cstat-no" title="statement not covered" >if(!(i=e.definition.validate))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span></span></span></span>f(void 0===i)<span class="cstat-no" title="statement not covered" >throw new Error('custom keyword "'+e.keyword+'"failed to compile');v</span></span>ar h=<span class="cstat-no" title="statement not covered" >O.length;<span class="cstat-no" title="statement not covered" ></span>return O[h]=i,{code:"customRule"+h,validate:i}}</span>}},function(e,r,t){"use strict";var a=t(55),o=t(5),n=t(50),s=t(15),i=t(14),u=t(49),l=t(48),c=t(27),h=t(2);e.exports=y,y.prototype.validate=function(e,r){var t;<span class="missing-if-branch" title="else path not taken" >E</span>if("string"==typeof e){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(t=this.getSchema(e)))<span class="cstat-no" title="statement not covered" >throw new Error('no schema with key or ref "'+e+'"')}</span>else{var a=<span class="cstat-no" title="statement not covered" >this._addSchema(e);<span class="cstat-no" title="statement not covered" ></span>t=a.validate||this._compile(a)}</span>var o=t(r);!0!==t.$async&amp;&amp;(this.errors=t.errors);return o},y.prototype.compile=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var t=<span class="cstat-no" title="statement not covered" >this._addSchema(e,void 0,r);<span class="cstat-no" title="statement not covered" ></span>return t.validate||this._compile(t)}</span>,y.prototype.addSchema=function(e,r,t,a){<span class="missing-if-branch" title="if path not taken" >I</span>if(Array.isArray(e)){<span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >this.addSchema(e[n],void 0,t,a);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>var s=this._getId(e);<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0!==s&amp;&amp;"string"!=typeof s)<span class="cstat-no" title="statement not covered" >throw new Error("schema id must be string");r</span>eturn _(this,r=o.normalizeId(r||<span class="branch-1 cbranch-no" title="branch not covered" >s)</span>),this._schemas[r]=this._addSchema(e,t,a,!0),this},y.prototype.addMetaSchema=function(e,r,t){return this.addSchema(e,r,t,!0),this},y.prototype.validateSchema=function(e,r){var t=e.$schema;<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0!==t&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"string"!=typeof t)<span class="cstat-no" title="statement not covered" ></span>throw new Error("$schema must be a string");<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!(t=t||this._opts.defaultMeta||(a=this,o=a._opts.meta,a._opts.defaultMeta="object"==typeof o?<span class="branch-0 cbranch-no" title="branch not covered" >a._getId(o)||o:</span>a.getSchema(d)?d:<span class="branch-1 cbranch-no" title="branch not covered" >void 0,</span>a._opts.defaultMeta)))<span class="cstat-no" title="statement not covered" >return this.logger.warn("meta-schema not available"),this.errors=null,!0;v</span>ar a,o;var n,s=this._formats.uri;this._formats.uri="function"==typeof s?<span class="branch-0 cbranch-no" title="branch not covered" >this._schemaUriFormatFunc:</span>this._schemaUriFormat;try{n=this.validate(t,e)}finally{this._formats.uri=s}<span class="missing-if-branch" title="if path not taken" >I</span>if(!n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r)</span>{var i=<span class="cstat-no" title="statement not covered" >"schema is invalid: "+this.errorsText();<span class="cstat-no" title="statement not covered" ></span>if("log"!=this._opts.validateSchema)<span class="cstat-no" title="statement not covered" >throw new Error(i);<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.error(i)}</span>return n},y.prototype.getSchema=function(e){var r=g(this,e);switch(typeof r){case"object":return r.validate||this._compile(r);<span class="branch-1 cbranch-no" title="branch not covered" >case"string":<span class="cstat-no" title="statement not covered" >return this.getSchema(r);<span class="branch-2 cbranch-no" title="branch not covered" >c</span></span>ase"undefined":<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var t=<span class="cstat-no" title="statement not covered" >o.schema.call(e,{schema:{}},r);<span class="cstat-no" title="statement not covered" ></span>if(t){var n=<span class="cstat-no" title="statement not covered" >t.schema,</span>i=<span class="cstat-no" title="statement not covered" >t.root,</span>u=<span class="cstat-no" title="statement not covered" >t.baseId,</span>l=<span class="cstat-no" title="statement not covered" >a.call(e,n,i,void 0,u);<span class="cstat-no" title="statement not covered" ></span>return e._fragments[r]=new s({ref:r,fragment:!0,schema:n,root:i,baseId:u,validate:l}),l}</span>}</span>(this,e)}</span></span>},y.prototype.removeSchema=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e instanceof RegExp)<span class="cstat-no" title="statement not covered" >return P(this,this._schemas,e),P(this,this._refs,e),this;<span class="cstat-no" title="statement not covered" >s</span></span>witch(typeof e){case"undefined":<span class="cstat-no" title="statement not covered" >return P(this,this._schemas),P(this,this._refs),this._cache.clear(),this;c</span>ase"string":var r=<span class="cstat-no" title="statement not covered" >g(this,e);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;this._cache.del(r.cacheKey),delete this._schemas[e],delete this._refs[e],this;c</span>ase"object":var t=<span class="cstat-no" title="statement not covered" >this._opts.serialize,</span>a=<span class="cstat-no" title="statement not covered" >t?t(e):e;<span class="cstat-no" title="statement not covered" ></span>this._cache.del(a);v</span>ar n=<span class="cstat-no" title="statement not covered" >this._getId(e);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(n=o.normalizeId(n),delete this._schemas[n],delete this._refs[n])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>,y.prototype.addFormat=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >"string"==typeof r&amp;&amp;(r=new RegExp(r));<span class="cstat-no" title="statement not covered" >r</span>eturn this._formats[e]=r,this}</span>,y.prototype.errorsText=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(!(e=e||this.errors))<span class="cstat-no" title="statement not covered" >return"No errors";<span class="cstat-no" title="statement not covered" >f</span></span>or(var t=void 0===(r=r||{}).separator?", ":r.separator,a=void 0===r.dataVar?"data":r.dataVar,o="",n=0;n&lt;e.length;n++){var s=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;(o+=a+s.dataPath+" "+s.message+t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.slice(0,-t.length)}</span>,y.prototype._addSchema=function(e,r,t,a){<span class="missing-if-branch" title="if path not taken" >I</span>if("object"!=typeof e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"boolean"!=typeof e)<span class="cstat-no" title="statement not covered" ></span>throw new Error("schema should be object or boolean");v</span>ar n=this._opts.serialize,i=n?n(e):<span class="branch-1 cbranch-no" title="branch not covered" >e,</span>u=this._cache.get(i);<span class="missing-if-branch" title="if path not taken" >I</span>if(u)<span class="cstat-no" title="statement not covered" >return u;a</span>=a||<span class="branch-1 cbranch-no" title="branch not covered" >!1!==this._opts.addUsedSchema;</span>var l=o.normalizeId(this._getId(e));l&amp;&amp;a&amp;&amp;_(this,l);var c,h=!1!==this._opts.validateSchema&amp;&amp;!r;h&amp;&amp;!(c=l&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >l==o.normalizeId(e.$schema))</span>&amp;&amp;this.validateSchema(e,!0);var f=o.ids.call(this,e),p=new s({id:l,schema:e,localRefs:f,cacheKey:i,meta:t});"#"!=l[0]&amp;&amp;a&amp;&amp;(this._refs[l]=p);this._cache.put(i,p),h&amp;&amp;c&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >this.validateSchema(e,!0);</span>return p},y.prototype._compile=function(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.compiling)<span class="cstat-no" title="statement not covered" >return e.validate=n,n.schema=e.schema,n.errors=null,n.root=r||n,!0===e.schema.$async&amp;&amp;(n.$async=!0),n;v</span>ar t,o;e.compiling=!0,e.meta&amp;&amp;(t=this._opts,this._opts=this._metaOpts);try{o=a.call(this,e.schema,r,e.localRefs)}finally{e.compiling=!1,e.meta&amp;&amp;(this._opts=t)}return e.validate=o,e.refs=o.refs,e.refVal=o.refVal,e.root=o.root,o;function <span class="fstat-no" title="function not covered" >n(</span>){var r=<span class="cstat-no" title="statement not covered" >e.validate,</span>t=<span class="cstat-no" title="statement not covered" >r.apply(null,arguments);<span class="cstat-no" title="statement not covered" ></span>return n.errors=r.errors,t}</span>},y.prototype.compileAsync=t(26);var f=t(25);y.prototype.addKeyword=f.add,y.prototype.getKeyword=f.get,y.prototype.removeKeyword=f.remove;var p=t(3);y.ValidationError=p.Validation,y.MissingRefError=p.MissingRef,y.$dataMetaSchema=c;var d="http://json-schema.org/draft-07/schema",m=["removeAdditional","useDefaults","coerceTypes"],v=["/properties"];function y(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(this instanceof y))<span class="cstat-no" title="statement not covered" >return new y(e);e</span>=this._opts=h.copy(e)||<span class="branch-1 cbranch-no" title="branch not covered" >{},</span>function(e){var r=e._opts.logger;<span class="missing-if-branch" title="if path not taken" >I</span>if(!1===r)<span class="cstat-no" title="statement not covered" >e.logger={log:S,warn:S,error:S};e</span>lse{<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0===r&amp;&amp;(r=console),!("object"==typeof r&amp;&amp;r.log&amp;&amp;r.warn&amp;&amp;r.error))<span class="cstat-no" title="statement not covered" >throw new Error("logger must implement log, warn and error methods");e</span>.logger=r}}(this),this._schemas={},this._refs={},this._fragments={},this._formats=u(e.format);var r=this._schemaUriFormat=this._formats["uri-reference"];this._schemaUriFormatFunc=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r.test(e)}</span>,this._cache=e.cache||new n,this._loadingSchemas={},this._compilations=[],this.RULES=l(),this._getId=function(e){switch(e.schemaId){<span class="branch-0 cbranch-no" title="branch not covered" >case"auto":<span class="cstat-no" title="statement not covered" >return w;<span class="branch-1 cbranch-no" title="branch not covered" >c</span></span>ase"id":<span class="cstat-no" title="statement not covered" >return E;d</span></span>efault:return b}}(e),e.loopRequired=e.loopRequired||1/0,"property"==e.errorDataPath&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e._errorDataPathProperty=!0)</span>,void 0===e.serialize&amp;&amp;(e.serialize=i),this._metaOpts=function(e){for(var r=h.copy(e._opts),t=0;t&lt;m.length;t++)delete r[m[t]];return r}(this),e.formats&amp;&amp;<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r in e._opts.formats){var t=<span class="cstat-no" title="statement not covered" >e._opts.formats[r];<span class="cstat-no" title="statement not covered" ></span>e.addFormat(r,t)}</span>}</span>(this),</span>function(e){var r;e._opts.$data&amp;&amp;(r=t(23),e.addMetaSchema(r,r.$id,!0));<span class="missing-if-branch" title="if path not taken" >I</span>if(!1===e._opts.meta)<span class="cstat-no" title="statement not covered" >return;v</span>ar a=t(22);e._opts.$data&amp;&amp;(a=c(a,v));e.addMetaSchema(a,d,!0),e._refs["http://json-schema.org/schema"]=d}(this),"object"==typeof e.meta&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >this.addMetaSchema(e.meta),</span>function(e){var r=e._opts.schemas;<span class="missing-if-branch" title="else path not taken" >E</span>if(!r)return;<span class="cstat-no" title="statement not covered" >if(Array.isArray(r))<span class="cstat-no" title="statement not covered" >e.addSchema(r);e</span>lse <span class="cstat-no" title="statement not covered" >for(var t in r)<span class="cstat-no" title="statement not covered" >e.addSchema(r[t],t)}</span></span></span>(this)}function g(e,r){return r=o.normalizeId(r),e._schemas[r]||<span class="branch-1 cbranch-no" title="branch not covered" >e._refs[r]|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >e._fragments[r]}</span>function <span class="fstat-no" title="function not covered" >P(</span>e,r,t){<span class="cstat-no" title="statement not covered" >for(var a in r){var o=<span class="cstat-no" title="statement not covered" >r[a];<span class="cstat-no" title="statement not covered" ></span>o.meta||t&amp;&amp;!t.test(a)||(e._cache.del(o.cacheKey),delete r[a])}</span>}</span>function <span class="fstat-no" title="function not covered" >E(</span>e){<span class="cstat-no" title="statement not covered" >return e.$id&amp;&amp;this.logger.warn("schema $id ignored",e.$id),e.id}</span>function b(e){return e.id&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.warn("schema id ignored",e.id),</span>e.$id}function <span class="fstat-no" title="function not covered" >w(</span>e){<span class="cstat-no" title="statement not covered" >if(e.$id&amp;&amp;e.id&amp;&amp;e.$id!=e.id)<span class="cstat-no" title="statement not covered" >throw new Error("schema $id is different from id");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.$id||e.id}</span>function _(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(e._schemas[r]||e._refs[r])<span class="cstat-no" title="statement not covered" >throw new Error('schema with key or id "'+r+'" already exists')}</span>function <span class="fstat-no" title="function not covered" >S(</span>){}},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r.AjvWrapper=void 0;var a,o=function(){function e(e,r){for(var t=0;t&lt;r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(r,t,a){return t&amp;&amp;e(r.prototype,t),a&amp;&amp;e(r,a),r}}(),n=t(0),s=t(8),i=t(56),u=(a=i)&amp;&amp;a.__esModule?<span class="branch-0 cbranch-no" title="branch not covered" >a:</span>{default:a};r.AjvWrapper=function(){function e(r,t){var a=arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:<span class="branch-1 cbranch-no" title="branch not covered" >{};<span class="missing-if-branch" title="if path not taken" >I</span></span>if(function(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e instanceof r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span>(this,e),!(r&amp;&amp;r instanceof s.RxVO))<span class="cstat-no" title="statement not covered" >throw"RxVO is required at arguments[0]";O</span>bject.defineProperty(this,"$rxvo",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return r}</span>,enumerable:!1});var o=Object.assign(l,a);Object.defineProperty(this,"options",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o}</span>,enumerable:!0});var i=new u.default(o);n._ajvRef.set(this,i),void 0!==t&amp;&amp;i.addSchema(t,"root"),Object.seal(this)}return o(e,[{key:"exec",value:function(e,r){return this.$ajv.validate(e,r)}},{key:"$ajv",get:function(){return n._ajvRef.get(this)}}],[{key:"resolvePath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"not yet implemented"}</span>}]),e}();var l={$data:!0,jsonPointers:!0}},function(e,r){e.exports=require("rxjs/Rx")},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),r.ObserverBuilder=void 0;var a=function(){function e(e,r){for(var t=0;t&lt;r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&amp;&amp;(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(r,t,a){return t&amp;&amp;e(r.prototype,t),a&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e(r,a),</span>r}}(),o=t(0),n=t(58);var s=new WeakMap;r.ObserverBuilder=function(){function e(){!function(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e instanceof r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function")}</span>(this,e),o._observers.set(this,new WeakMap),s.set(this,[])}return a(e,[{key:"get",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return o._observers.get(this).get(e)||null}</span>},{key:"getObserverForPath",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >s.get(this).find(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return r[0]===""+e}</span>);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;r.length&gt;1?this.get(r[1]):null}</span>},{key:"list",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.get(this).map(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e[0]}</span>)}</span>},{key:"create",value:function(e){var r=o._observers.get(this),t={onNext:new n.BehaviorSubject(null).skip(1),onError:new n.BehaviorSubject(null).skip(1),onComplete:new n.BehaviorSubject(null).skip(1)};return r.set(e,t),s.get(this).splice(-1,0,[""+e.path,e]),r.get(e)}},{key:"next",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this.get(e);<span class="cstat-no" title="statement not covered" ></span>null!==r&amp;&amp;r.onNext.next(e)}</span>},{key:"complete",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this.get(e);<span class="cstat-no" title="statement not covered" ></span>null!==r&amp;&amp;r.onComplete.next(e)}</span>},{key:"error",value:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var t=<span class="cstat-no" title="statement not covered" >this.get(e);<span class="cstat-no" title="statement not covered" ></span>null!==t&amp;&amp;t.onError.next(r)}</span>}]),e}()},function(e,r,t){var a;"undefined"!=typeof self&amp;&amp;self,a=function(){return function(e){var r={};function t(a){if(r[a])return r[a].exports;var o=r[a]={i:a,l:!1,exports:{}};return e[a].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=r,t.d=function(e,r,a){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:a})},t.n=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.__esModule?<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.default}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e}</span>;<span class="cstat-no" title="statement not covered" ></span>return t.d(r,"a",r),r}</span>,t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=0)}([function(e,r,t){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var a=t(1);t.d(r,"Fun",function(){return a.a});var o=t(7);t.d(r,"Obj",function(){return o.a});var n=t(8);t.d(r,"Str",function(){return n.a});r.exists=(e=&gt;null!=e)},function(e,r,t){"use strict";(function(e){t(0);class a{static getFunctionName(e){let r=e.toString().match(/function+\s{1,}([a-zA-Z_0-9\$]*)/);return null!==r?r[1]:<span class="branch-1 cbranch-no" title="branch not covered" >null}</span>static getConstructorName(e){"Function"===e.constructor.name&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e=new e)</span>;let r=null;return null!==(r=this.getFunctionName(e.constructor))?r:<span class="branch-1 cbranch-no" title="branch not covered" >null}<span class="fstat-no" title="function not covered" ></span>st</span>atic construct(e,r){<span class="cstat-no" title="statement not covered" >return new(e.bind.apply(e,[null].concat(r)))}<span class="fstat-no" title="function not covered" ></span>st</span>atic get factory(){<span class="cstat-no" title="statement not covered" >return a.construct.bind(null,Function)}<span class="fstat-no" title="function not covered" ></span>st</span>atic fromString(e){let r=<span class="cstat-no" title="statement not covered" >e.replace(/\n/g,"").replace(/[\s]{2,}/g,"");<span class="cstat-no" title="statement not covered" ></span>if(null!==(r=r.match(/^function+[\s]{1,}[a-zA-Z0-9_]*\(([a-zA-Z0-9_\s,]*)\)+\s?\{+(.*)\}+$/)))<span class="cstat-no" title="statement not covered" >return a.factory([].concat(r[1],r[2]));l</span></span>et t=<span class="cstat-no" title="statement not covered" >e.match(new RegExp(`^Native::(${Object.keys(this.natives).join("|")})+$`));<span class="cstat-no" title="statement not covered" ></span>return null!==t?this.natives[t[1]]:null}<span class="fstat-no" title="function not covered" ></span>st</span>atic toString(e){<span class="cstat-no" title="statement not covered" >if("function"!=typeof e)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et r=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return null!=(r=e.toString()).match(/.*\[native code\].*/)?`Native::${this.getFunctionName(e)}`:r}<span class="fstat-no" title="function not covered" ></span>st</span>atic get natives(){<span class="cstat-no" title="statement not covered" >return{Array:Array,ArrayBuffer:ArrayBuffer,Boolean:Boolean,Buffer:e,ArrayBuffer:ArrayBuffer,Date:Date,Number:Number,Object:Object,String:String,Function:Function}}</span>}r.a=a}).call(r,t(2).Buffer)},function(e,r,t){"use strict";(function(e){var a=t(4),o=t(5),n=t(6);function s(){return u.TYPED_ARRAY_SUPPORT?2147483647:<span class="branch-1 cbranch-no" title="branch not covered" >1073741823}</span>function <span class="fstat-no" title="function not covered" >i(</span>e,r){<span class="cstat-no" title="statement not covered" >if(s()&lt;r)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid typed array length");<span class="cstat-no" title="statement not covered" >r</span></span>eturn u.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(r)).__proto__=u.prototype:(null===e&amp;&amp;(e=new u(r)),e.length=r),e}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,r,t){<span class="cstat-no" title="statement not covered" >if(!(u.TYPED_ARRAY_SUPPORT||this instanceof u))<span class="cstat-no" title="statement not covered" >return new u(e,r,t);<span class="cstat-no" title="statement not covered" >i</span></span>f("number"==typeof e){<span class="cstat-no" title="statement not covered" >if("string"==typeof r)<span class="cstat-no" title="statement not covered" >throw new Error("If encoding is specified then the first argument must be a string");<span class="cstat-no" title="statement not covered" >r</span></span>eturn h(this,e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l(this,e,r,t)}</span>function <span class="fstat-no" title="function not covered" >l(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >if("number"==typeof r)<span class="cstat-no" title="statement not covered" >throw new TypeError('"value" argument must not be a number');<span class="cstat-no" title="statement not covered" >r</span></span>eturn"undefined"!=typeof ArrayBuffer&amp;&amp;r instanceof ArrayBuffer?<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a){<span class="cstat-no" title="statement not covered" >if(r.byteLength,t&lt;0||r.byteLength&lt;t)<span class="cstat-no" title="statement not covered" >throw new RangeError("'offset' is out of bounds");<span class="cstat-no" title="statement not covered" >i</span></span>f(r.byteLength&lt;t+(a||0))<span class="cstat-no" title="statement not covered" >throw new RangeError("'length' is out of bounds");<span class="cstat-no" title="statement not covered" >r</span></span>=void 0===t&amp;&amp;void 0===a?new Uint8Array(r):void 0===a?new Uint8Array(r,t):new Uint8Array(r,t,a);<span class="cstat-no" title="statement not covered" >u</span>.TYPED_ARRAY_SUPPORT?(e=r).__proto__=u.prototype:e=f(e,r);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>(e,r,t,a):"string"==typeof r?<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >"string"==typeof t&amp;&amp;""!==t||(t="utf8");<span class="cstat-no" title="statement not covered" >i</span>f(!u.isEncoding(t))<span class="cstat-no" title="statement not covered" >throw new TypeError('"encoding" must be a valid string encoding');v</span></span>ar a=<span class="cstat-no" title="statement not covered" >0|d(r,t),</span>o=<span class="cstat-no" title="statement not covered" >(e=i(e,a)).write(r,t);<span class="cstat-no" title="statement not covered" ></span>o!==a&amp;&amp;(e=e.slice(0,o));<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>(e,r,t):<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(u.isBuffer(r)){var t=<span class="cstat-no" title="statement not covered" >0|p(r.length);<span class="cstat-no" title="statement not covered" ></span>return 0===(e=i(e,t)).length?e:(r.copy(e,0,0,t),e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r){<span class="cstat-no" title="statement not covered" >if("undefined"!=typeof ArrayBuffer&amp;&amp;r.buffer instanceof ArrayBuffer||"length"in r)<span class="cstat-no" title="statement not covered" >return"number"!=typeof r.length||(a=r.length)!=a?i(e,0):f(e,r);<span class="cstat-no" title="statement not covered" >i</span></span>f("Buffer"===r.type&amp;&amp;n(r.data))<span class="cstat-no" title="statement not covered" >return f(e,r.data)}</span></span>v</span>ar a;<span class="cstat-no" title="statement not covered" >throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}</span>(e,r)}</span>function <span class="fstat-no" title="function not covered" >c(</span>e){<span class="cstat-no" title="statement not covered" >if("number"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError('"size" argument must be a number');<span class="cstat-no" title="statement not covered" >i</span></span>f(e&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError('"size" argument must not be negative')}</span></span>function <span class="fstat-no" title="function not covered" >h(</span>e,r){<span class="cstat-no" title="statement not covered" >if(c(r),e=i(e,r&lt;0?0:0|p(r)),!u.TYPED_ARRAY_SUPPORT)<span class="cstat-no" title="statement not covered" >for(var t=0;t&lt;r;++t)<span class="cstat-no" title="statement not covered" >e[t]=0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >f(</span>e,r){var t=<span class="cstat-no" title="statement not covered" >r.length&lt;0?0:0|p(r.length);<span class="cstat-no" title="statement not covered" ></span>e=i(e,t);<span class="cstat-no" title="statement not covered" >f</span>or(var a=0;a&lt;t;a+=1)<span class="cstat-no" title="statement not covered" >e[a]=255&amp;r[a];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >p(</span>e){<span class="cstat-no" title="statement not covered" >if(e&gt;=s())<span class="cstat-no" title="statement not covered" >throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s().toString(16)+" bytes");<span class="cstat-no" title="statement not covered" >r</span></span>eturn 0|e}</span>function <span class="fstat-no" title="function not covered" >d(</span>e,r){<span class="cstat-no" title="statement not covered" >if(u.isBuffer(e))<span class="cstat-no" title="statement not covered" >return e.length;<span class="cstat-no" title="statement not covered" >i</span></span>f("undefined"!=typeof ArrayBuffer&amp;&amp;"function"==typeof ArrayBuffer.isView&amp;&amp;(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))<span class="cstat-no" title="statement not covered" >return e.byteLength;<span class="cstat-no" title="statement not covered" >"</span></span>string"!=typeof e&amp;&amp;(e=""+e);v</span>ar t=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>if(0===t)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var a=!1;;)<span class="cstat-no" title="statement not covered" >switch(r){case"ascii":case"latin1":case"binary":<span class="cstat-no" title="statement not covered" >return t;c</span>ase"utf8":case"utf-8":case void 0:<span class="cstat-no" title="statement not covered" >return z(e).length;c</span>ase"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return 2*t;c</span>ase"hex":<span class="cstat-no" title="statement not covered" >return t&gt;&gt;&gt;1;c</span>ase"base64":<span class="cstat-no" title="statement not covered" >return L(e).length;d</span>efault:<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >return z(e).length;<span class="cstat-no" title="statement not covered" >r</span></span>=(""+r).toLowerCase(),a=!0}</span>}</span></span>function <span class="fstat-no" title="function not covered" >m(</span>e,r,t){var a=<span class="cstat-no" title="statement not covered" >e[r];<span class="cstat-no" title="statement not covered" ></span>e[r]=e[t],e[t]=a}</span>function <span class="fstat-no" title="function not covered" >v(</span>e,r,t,a,o){<span class="cstat-no" title="statement not covered" >if(0===e.length)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span></span>f("string"==typeof t?(a=t,t=0):t&gt;2147483647?t=2147483647:t&lt;-2147483648&amp;&amp;(t=-2147483648),t=+t,isNaN(t)&amp;&amp;(t=o?0:e.length-1),t&lt;0&amp;&amp;(t=e.length+t),t&gt;=e.length){<span class="cstat-no" title="statement not covered" >if(o)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >t</span></span>=e.length-1}</span>else <span class="cstat-no" title="statement not covered" >if(t&lt;0){<span class="cstat-no" title="statement not covered" >if(!o)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >t</span></span>=0}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f("string"==typeof r&amp;&amp;(r=u.from(r,a)),u.isBuffer(r))<span class="cstat-no" title="statement not covered" >return 0===r.length?-1:y(e,r,t,a,o);<span class="cstat-no" title="statement not covered" >i</span></span>f("number"==typeof r)<span class="cstat-no" title="statement not covered" >return r&amp;=255,u.TYPED_ARRAY_SUPPORT&amp;&amp;"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(e,r,t):Uint8Array.prototype.lastIndexOf.call(e,r,t):y(e,[r],t,a,o);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError("val must be string, number or Buffer")}</span>function <span class="fstat-no" title="function not covered" >y(</span>e,r,t,a,o){var n,s=<span class="cstat-no" title="statement not covered" >1,</span>i=<span class="cstat-no" title="statement not covered" >e.length,</span>u=<span class="cstat-no" title="statement not covered" >r.length;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==a&amp;&amp;("ucs2"===(a=String(a).toLowerCase())||"ucs-2"===a||"utf16le"===a||"utf-16le"===a)){<span class="cstat-no" title="statement not covered" >if(e.length&lt;2||r.length&lt;2)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >s</span></span>=2,i/=2,u/=2,t/=2}</span>f</span>unction <span class="fstat-no" title="function not covered" >l(</span>e,r){<span class="cstat-no" title="statement not covered" >return 1===s?e[r]:e.readUInt16BE(r*s)}<span class="cstat-no" title="statement not covered" ></span>if(o){var c=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>for(n=t;n&lt;i;n++)<span class="cstat-no" title="statement not covered" >if(l(e,n)===l(r,-1===c?0:n-c)){<span class="cstat-no" title="statement not covered" >if(-1===c&amp;&amp;(c=n),n-c+1===u)<span class="cstat-no" title="statement not covered" >return c*s}</span></span>else<span class="cstat-no" title="statement not covered" >-1!==c&amp;&amp;(n-=n-c),c=-1}</span></span></span>else <span class="cstat-no" title="statement not covered" >for(t+u&gt;i&amp;&amp;(t=i-u),n=t;n&gt;=0;n--){<span class="cstat-no" title="statement not covered" >for(var h=!0,f=0;f&lt;u;f++)<span class="cstat-no" title="statement not covered" >if(l(e,n+f)!==l(r,f)){<span class="cstat-no" title="statement not covered" >h=!1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(h)<span class="cstat-no" title="statement not covered" >return n}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn-1}</span>function <span class="fstat-no" title="function not covered" >g(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >t=Number(t)||0;v</span>ar o=<span class="cstat-no" title="statement not covered" >e.length-t;<span class="cstat-no" title="statement not covered" ></span>a?(a=Number(a))&gt;o&amp;&amp;(a=o):a=o;v</span>ar n=<span class="cstat-no" title="statement not covered" >r.length;<span class="cstat-no" title="statement not covered" ></span>if(n%2!=0)<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid hex string");<span class="cstat-no" title="statement not covered" >a</span></span>&gt;n/2&amp;&amp;(a=n/2);<span class="cstat-no" title="statement not covered" >f</span>or(var s=0;s&lt;a;++s){var i=<span class="cstat-no" title="statement not covered" >parseInt(r.substr(2*s,2),16);<span class="cstat-no" title="statement not covered" ></span>if(isNaN(i))<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >e</span></span>[t+s]=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>function <span class="fstat-no" title="function not covered" >P(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >return B(z(r,e.length-t),e,t,a)}</span>function <span class="fstat-no" title="function not covered" >E(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >return B(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=[],t=0;t&lt;e.length;++t)<span class="cstat-no" title="statement not covered" >r.push(255&amp;e.charCodeAt(t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>(r),e,t,a)}</span>function <span class="fstat-no" title="function not covered" >b(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >return E(e,r,t,a)}</span>function <span class="fstat-no" title="function not covered" >w(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >return B(L(r),e,t,a)}</span>function <span class="fstat-no" title="function not covered" >_(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >return B(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >for(var t,a,o,n=[],s=0;s&lt;e.length&amp;&amp;!((r-=2)&lt;0);++s)<span class="cstat-no" title="statement not covered" >t=e.charCodeAt(s),a=t&gt;&gt;8,o=t%256,n.push(o),n.push(a);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>(r,e.length-t),e,t,a)}</span>function <span class="fstat-no" title="function not covered" >S(</span>e,r,t){<span class="cstat-no" title="statement not covered" >return 0===r&amp;&amp;t===e.length?a.fromByteArray(e):a.fromByteArray(e.slice(r,t))}</span>function <span class="fstat-no" title="function not covered" >x(</span>e,r,t){<span class="cstat-no" title="statement not covered" >t=Math.min(e.length,t);<span class="cstat-no" title="statement not covered" >f</span>or(var a=[],o=r;o&lt;t;){var n,s,i,u,l=<span class="cstat-no" title="statement not covered" >e[o],</span>c=<span class="cstat-no" title="statement not covered" >null,</span>h=<span class="cstat-no" title="statement not covered" >l&gt;239?4:l&gt;223?3:l&gt;191?2:1;<span class="cstat-no" title="statement not covered" ></span>if(o+h&lt;=t)<span class="cstat-no" title="statement not covered" >switch(h){case 1:<span class="cstat-no" title="statement not covered" >l&lt;128&amp;&amp;(c=l);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >128==(192&amp;(n=e[o+1]))&amp;&amp;(u=(31&amp;l)&lt;&lt;6|63&amp;n)&gt;127&amp;&amp;(c=u);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >n=e[o+1],s=e[o+2],128==(192&amp;n)&amp;&amp;128==(192&amp;s)&amp;&amp;(u=(15&amp;l)&lt;&lt;12|(63&amp;n)&lt;&lt;6|63&amp;s)&gt;2047&amp;&amp;(u&lt;55296||u&gt;57343)&amp;&amp;(c=u);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >n=e[o+1],s=e[o+2],i=e[o+3],128==(192&amp;n)&amp;&amp;128==(192&amp;s)&amp;&amp;128==(192&amp;i)&amp;&amp;(u=(15&amp;l)&lt;&lt;18|(63&amp;n)&lt;&lt;12|(63&amp;s)&lt;&lt;6|63&amp;i)&gt;65535&amp;&amp;u&lt;1114112&amp;&amp;(c=u)}<span class="cstat-no" title="statement not covered" ></span>n</span></span>ull===c?(c=65533,h=1):c&gt;65535&amp;&amp;(c-=65536,a.push(c&gt;&gt;&gt;10&amp;1023|55296),c=56320|1023&amp;c),a.push(c),o+=h}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>if(r&lt;=R)<span class="cstat-no" title="statement not covered" >return String.fromCharCode.apply(String,e);v</span></span>ar t=<span class="cstat-no" title="statement not covered" >"",</span>a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;a&lt;r;)<span class="cstat-no" title="statement not covered" >t+=String.fromCharCode.apply(String,e.slice(a,a+=R));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>(a)}</span>r.Buffer=u,r.SlowBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >+e!=e&amp;&amp;(e=0);<span class="cstat-no" title="statement not covered" >r</span>eturn u.alloc(+e)}</span>,r.INSPECT_MAX_BYTES=50,u.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?<span class="branch-0 cbranch-no" title="branch not covered" >e.TYPED_ARRAY_SUPPORT:</span>function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&amp;&amp;"function"==typeof e.subarray&amp;&amp;0===e.subarray(1,1).byteLength}catch(e){<span class="cstat-no" title="statement not covered" >return!1}</span>}(),r.kMaxLength=s(),u.poolSize=8192,u._augment=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.__proto__=u.prototype,e}</span>,u.from=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return l(null,e,r,t)}</span>,u.TYPED_ARRAY_SUPPORT&amp;&amp;(u.prototype.__proto__=Uint8Array.prototype,u.__proto__=Uint8Array,"undefined"!=typeof Symbol&amp;&amp;Symbol.species&amp;&amp;u[Symbol.species]===u&amp;&amp;Object.defineProperty(u,Symbol.species,{value:null,configurable:!0})),u.alloc=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a){<span class="cstat-no" title="statement not covered" >return c(r),r&lt;=0?i(e,r):void 0!==t?"string"==typeof a?i(e,r).fill(t,a):i(e,r).fill(t):i(e,r)}</span>(null,e,r,t)}</span>,u.allocUnsafe=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return h(null,e)}</span>,u.allocUnsafeSlow=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return h(null,e)}</span>,u.isBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!(null==e||!e._isBuffer)}</span>,u.compare=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(!u.isBuffer(e)||!u.isBuffer(r))<span class="cstat-no" title="statement not covered" >throw new TypeError("Arguments must be Buffers");<span class="cstat-no" title="statement not covered" >i</span></span>f(e===r)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var t=e.length,a=r.length,o=0,n=Math.min(t,a);o&lt;n;++o)<span class="cstat-no" title="statement not covered" >if(e[o]!==r[o]){<span class="cstat-no" title="statement not covered" >t=e[o],a=r[o];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t&lt;a?-1:a&lt;t?1:0}</span>,u.isEncoding=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return!0;d</span>efault:<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>,u.concat=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(!n(e))<span class="cstat-no" title="statement not covered" >throw new TypeError('"list" argument must be an Array of Buffers');<span class="cstat-no" title="statement not covered" >i</span></span>f(0===e.length)<span class="cstat-no" title="statement not covered" >return u.alloc(0);v</span></span>ar t;<span class="cstat-no" title="statement not covered" >if(void 0===r)<span class="cstat-no" title="statement not covered" >for(r=0,t=0;t&lt;e.length;++t)<span class="cstat-no" title="statement not covered" >r+=e[t].length;v</span></span></span>ar a=<span class="cstat-no" title="statement not covered" >u.allocUnsafe(r),</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;e.length;++t){var s=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>if(!u.isBuffer(s))<span class="cstat-no" title="statement not covered" >throw new TypeError('"list" argument must be an Array of Buffers');<span class="cstat-no" title="statement not covered" >s</span></span>.copy(a,o),o+=s.length}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>,u.byteLength=d,u.prototype._isBuffer=!0,u.prototype.swap16=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this.length;<span class="cstat-no" title="statement not covered" ></span>if(e%2!=0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Buffer size must be a multiple of 16-bits");<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=0;r&lt;e;r+=2)<span class="cstat-no" title="statement not covered" >m(this,r,r+1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,u.prototype.swap32=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this.length;<span class="cstat-no" title="statement not covered" ></span>if(e%4!=0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Buffer size must be a multiple of 32-bits");<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=0;r&lt;e;r+=4)<span class="cstat-no" title="statement not covered" >m(this,r,r+3),m(this,r+1,r+2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,u.prototype.swap64=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this.length;<span class="cstat-no" title="statement not covered" ></span>if(e%8!=0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Buffer size must be a multiple of 64-bits");<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=0;r&lt;e;r+=8)<span class="cstat-no" title="statement not covered" >m(this,r,r+7),m(this,r+1,r+6),m(this,r+2,r+5),m(this,r+3,r+4);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,u.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >0|this.length;<span class="cstat-no" title="statement not covered" ></span>return 0===e?"":0===arguments.length?x(this,0,e):<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){var a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if((void 0===r||r&lt;0)&amp;&amp;(r=0),r&gt;this.length)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >i</span></span>f((void 0===t||t&gt;this.length)&amp;&amp;(t=this.length),t&lt;=0)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >i</span></span>f((t&gt;&gt;&gt;=0)&lt;=(r&gt;&gt;&gt;=0))<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >f</span></span>or(e||(e="utf8");;)<span class="cstat-no" title="statement not covered" >switch(e){case"hex":<span class="cstat-no" title="statement not covered" >return A(this,r,t);c</span>ase"utf8":case"utf-8":<span class="cstat-no" title="statement not covered" >return x(this,r,t);c</span>ase"ascii":<span class="cstat-no" title="statement not covered" >return O(this,r,t);c</span>ase"latin1":case"binary":<span class="cstat-no" title="statement not covered" >return j(this,r,t);c</span>ase"base64":<span class="cstat-no" title="statement not covered" >return S(this,r,t);c</span>ase"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return F(this,r,t);d</span>efault:<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+e);<span class="cstat-no" title="statement not covered" >e</span></span>=(e+"").toLowerCase(),a=!0}</span>}</span></span>.apply(this,arguments)}</span>,u.prototype.equals=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!u.isBuffer(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("Argument must be a Buffer");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this===e||0===u.compare(this,e)}</span>,u.prototype.inspect=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >"",</span>t=<span class="cstat-no" title="statement not covered" >r.INSPECT_MAX_BYTES;<span class="cstat-no" title="statement not covered" ></span>return this.length&gt;0&amp;&amp;(e=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length&gt;t&amp;&amp;(e+=" ... ")),"&lt;Buffer "+e+"&gt;"}</span>,u.prototype.compare=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a,o){<span class="cstat-no" title="statement not covered" >if(!u.isBuffer(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("Argument must be a Buffer");<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0===r&amp;&amp;(r=0),void 0===t&amp;&amp;(t=e?e.length:0),void 0===a&amp;&amp;(a=0),void 0===o&amp;&amp;(o=this.length),r&lt;0||t&gt;e.length||a&lt;0||o&gt;this.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("out of range index");<span class="cstat-no" title="statement not covered" >i</span></span>f(a&gt;=o&amp;&amp;r&gt;=t)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(a&gt;=o)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r&gt;=t)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span></span>f(this===e)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=(o&gt;&gt;&gt;=0)-(a&gt;&gt;&gt;=0),s=(t&gt;&gt;&gt;=0)-(r&gt;&gt;&gt;=0),i=Math.min(n,s),l=this.slice(a,o),c=e.slice(r,t),h=0;h&lt;i;++h)<span class="cstat-no" title="statement not covered" >if(l[h]!==c[h]){<span class="cstat-no" title="statement not covered" >n=l[h],s=c[h];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn n&lt;s?-1:s&lt;n?1:0}</span>,u.prototype.includes=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return-1!==this.indexOf(e,r,t)}</span>,u.prototype.indexOf=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return v(this,e,r,t,!0)}</span>,u.prototype.lastIndexOf=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return v(this,e,r,t,!1)}</span>,u.prototype.write=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a){<span class="cstat-no" title="statement not covered" >if(void 0===r)<span class="cstat-no" title="statement not covered" >a="utf8",t=this.length,r=0;e</span>lse <span class="cstat-no" title="statement not covered" >if(void 0===t&amp;&amp;"string"==typeof r)<span class="cstat-no" title="statement not covered" >a=r,t=this.length,r=0;e</span>lse{<span class="cstat-no" title="statement not covered" >if(!isFinite(r))<span class="cstat-no" title="statement not covered" >throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");<span class="cstat-no" title="statement not covered" >r</span></span>|=0,isFinite(t)?(t|=0,void 0===a&amp;&amp;(a="utf8")):(a=t,t=void 0)}</span>v</span></span>ar o=<span class="cstat-no" title="statement not covered" >this.length-r;<span class="cstat-no" title="statement not covered" ></span>if((void 0===t||t&gt;o)&amp;&amp;(t=o),e.length&gt;0&amp;&amp;(t&lt;0||r&lt;0)||r&gt;this.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Attempt to write outside buffer bounds");<span class="cstat-no" title="statement not covered" >a</span></span>||(a="utf8");<span class="cstat-no" title="statement not covered" >f</span>or(var n=!1;;)<span class="cstat-no" title="statement not covered" >switch(a){case"hex":<span class="cstat-no" title="statement not covered" >return g(this,e,r,t);c</span>ase"utf8":case"utf-8":<span class="cstat-no" title="statement not covered" >return P(this,e,r,t);c</span>ase"ascii":<span class="cstat-no" title="statement not covered" >return E(this,e,r,t);c</span>ase"latin1":case"binary":<span class="cstat-no" title="statement not covered" >return b(this,e,r,t);c</span>ase"base64":<span class="cstat-no" title="statement not covered" >return w(this,e,r,t);c</span>ase"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return _(this,e,r,t);d</span>efault:<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+a);<span class="cstat-no" title="statement not covered" >a</span></span>=(""+a).toLowerCase(),n=!0}</span>}</span></span>,u.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}}</span>;var R=4096;function <span class="fstat-no" title="function not covered" >O(</span>e,r,t){var a=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>t=Math.min(e.length,t);<span class="cstat-no" title="statement not covered" >f</span>or(var o=r;o&lt;t;++o)<span class="cstat-no" title="statement not covered" >a+=String.fromCharCode(127&amp;e[o]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>function <span class="fstat-no" title="function not covered" >j(</span>e,r,t){var a=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>t=Math.min(e.length,t);<span class="cstat-no" title="statement not covered" >f</span>or(var o=r;o&lt;t;++o)<span class="cstat-no" title="statement not covered" >a+=String.fromCharCode(e[o]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>function <span class="fstat-no" title="function not covered" >A(</span>e,r,t){var a=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>(!r||r&lt;0)&amp;&amp;(r=0),(!t||t&lt;0||t&gt;a)&amp;&amp;(t=a);<span class="cstat-no" title="statement not covered" >f</span>or(var o="",n=r;n&lt;t;++n)<span class="cstat-no" title="statement not covered" >o+=N(e[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>function <span class="fstat-no" title="function not covered" >F(</span>e,r,t){<span class="cstat-no" title="statement not covered" >for(var a=e.slice(r,t),o="",n=0;n&lt;a.length;n+=2)<span class="cstat-no" title="statement not covered" >o+=String.fromCharCode(a[n]+256*a[n+1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>function <span class="fstat-no" title="function not covered" >D(</span>e,r,t){<span class="cstat-no" title="statement not covered" >if(e%1!=0||e&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("offset is not uint");<span class="cstat-no" title="statement not covered" >i</span></span>f(e+r&gt;t)<span class="cstat-no" title="statement not covered" >throw new RangeError("Trying to access beyond buffer length")}</span></span>function <span class="fstat-no" title="function not covered" >$(</span>e,r,t,a,o,n){<span class="cstat-no" title="statement not covered" >if(!u.isBuffer(e))<span class="cstat-no" title="statement not covered" >throw new TypeError('"buffer" argument must be a Buffer instance');<span class="cstat-no" title="statement not covered" >i</span></span>f(r&gt;o||r&lt;n)<span class="cstat-no" title="statement not covered" >throw new RangeError('"value" argument is out of bounds');<span class="cstat-no" title="statement not covered" >i</span></span>f(t+a&gt;e.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range")}</span></span>function <span class="fstat-no" title="function not covered" >k(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >r&lt;0&amp;&amp;(r=65535+r+1);<span class="cstat-no" title="statement not covered" >f</span>or(var o=0,n=Math.min(e.length-t,2);o&lt;n;++o)<span class="cstat-no" title="statement not covered" >e[t+o]=(r&amp;255&lt;&lt;8*(a?o:1-o))&gt;&gt;&gt;8*(a?o:1-o)}</span></span>function <span class="fstat-no" title="function not covered" >I(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >r&lt;0&amp;&amp;(r=4294967295+r+1);<span class="cstat-no" title="statement not covered" >f</span>or(var o=0,n=Math.min(e.length-t,4);o&lt;n;++o)<span class="cstat-no" title="statement not covered" >e[t+o]=r&gt;&gt;&gt;8*(a?o:3-o)&amp;255}</span></span>function <span class="fstat-no" title="function not covered" >C(</span>e,r,t,a,o,n){<span class="cstat-no" title="statement not covered" >if(t+a&gt;e.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range");<span class="cstat-no" title="statement not covered" >i</span></span>f(t&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range")}</span></span>function <span class="fstat-no" title="function not covered" >T(</span>e,r,t,a,n){<span class="cstat-no" title="statement not covered" >return n||C(e,0,t,4),o.write(e,r,t,a,23,4),t+4}</span>function <span class="fstat-no" title="function not covered" >M(</span>e,r,t,a,n){<span class="cstat-no" title="statement not covered" >return n||C(e,0,t,8),o.write(e,r,t,a,52,8),t+8}</span>u.prototype.slice=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var t,a=<span class="cstat-no" title="statement not covered" >this.length;<span class="cstat-no" title="statement not covered" ></span>if((e=~~e)&lt;0?(e+=a)&lt;0&amp;&amp;(e=0):e&gt;a&amp;&amp;(e=a),(r=void 0===r?a:~~r)&lt;0?(r+=a)&lt;0&amp;&amp;(r=0):r&gt;a&amp;&amp;(r=a),r&lt;e&amp;&amp;(r=e),u.TYPED_ARRAY_SUPPORT)<span class="cstat-no" title="statement not covered" >(t=this.subarray(e,r)).__proto__=u.prototype;e</span>lse{var o=<span class="cstat-no" title="statement not covered" >r-e;<span class="cstat-no" title="statement not covered" ></span>t=new u(o,void 0);<span class="cstat-no" title="statement not covered" >f</span>or(var n=0;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >t[n]=this[n+e]}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t}</span>,u.prototype.readUIntLE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >e|=0,r|=0,t||D(e,r,this.length);<span class="cstat-no" title="statement not covered" >f</span>or(var a=this[e],o=1,n=0;++n&lt;r&amp;&amp;(o*=256);)<span class="cstat-no" title="statement not covered" >a+=this[e+n]*o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>,u.prototype.readUIntBE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >e|=0,r|=0,t||D(e,r,this.length);<span class="cstat-no" title="statement not covered" >f</span>or(var a=this[e+--r],o=1;r&gt;0&amp;&amp;(o*=256);)<span class="cstat-no" title="statement not covered" >a+=this[e+--r]*o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>,u.prototype.readUInt8=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,1,this.length),this[e]}</span>,u.prototype.readUInt16LE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,2,this.length),this[e]|this[e+1]&lt;&lt;8}</span>,u.prototype.readUInt16BE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,2,this.length),this[e]&lt;&lt;8|this[e+1]}</span>,u.prototype.readUInt32LE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,4,this.length),(this[e]|this[e+1]&lt;&lt;8|this[e+2]&lt;&lt;16)+16777216*this[e+3]}</span>,u.prototype.readUInt32BE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,4,this.length),16777216*this[e]+(this[e+1]&lt;&lt;16|this[e+2]&lt;&lt;8|this[e+3])}</span>,u.prototype.readIntLE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >e|=0,r|=0,t||D(e,r,this.length);<span class="cstat-no" title="statement not covered" >f</span>or(var a=this[e],o=1,n=0;++n&lt;r&amp;&amp;(o*=256);)<span class="cstat-no" title="statement not covered" >a+=this[e+n]*o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a&gt;=(o*=128)&amp;&amp;(a-=Math.pow(2,8*r)),a}</span>,u.prototype.readIntBE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >e|=0,r|=0,t||D(e,r,this.length);<span class="cstat-no" title="statement not covered" >f</span>or(var a=r,o=1,n=this[e+--a];a&gt;0&amp;&amp;(o*=256);)<span class="cstat-no" title="statement not covered" >n+=this[e+--a]*o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n&gt;=(o*=128)&amp;&amp;(n-=Math.pow(2,8*r)),n}</span>,u.prototype.readInt8=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,1,this.length),128&amp;this[e]?-1*(255-this[e]+1):this[e]}</span>,u.prototype.readInt16LE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >r||D(e,2,this.length);v</span>ar t=<span class="cstat-no" title="statement not covered" >this[e]|this[e+1]&lt;&lt;8;<span class="cstat-no" title="statement not covered" ></span>return 32768&amp;t?4294901760|t:t}</span>,u.prototype.readInt16BE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >r||D(e,2,this.length);v</span>ar t=<span class="cstat-no" title="statement not covered" >this[e+1]|this[e]&lt;&lt;8;<span class="cstat-no" title="statement not covered" ></span>return 32768&amp;t?4294901760|t:t}</span>,u.prototype.readInt32LE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,4,this.length),this[e]|this[e+1]&lt;&lt;8|this[e+2]&lt;&lt;16|this[e+3]&lt;&lt;24}</span>,u.prototype.readInt32BE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,4,this.length),this[e]&lt;&lt;24|this[e+1]&lt;&lt;16|this[e+2]&lt;&lt;8|this[e+3]}</span>,u.prototype.readFloatLE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,4,this.length),o.read(this,e,!0,23,4)}</span>,u.prototype.readFloatBE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,4,this.length),o.read(this,e,!1,23,4)}</span>,u.prototype.readDoubleLE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,8,this.length),o.read(this,e,!0,52,8)}</span>,u.prototype.readDoubleBE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r||D(e,8,this.length),o.read(this,e,!1,52,8)}</span>,u.prototype.writeUIntLE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a){<span class="cstat-no" title="statement not covered" >(e=+e,r|=0,t|=0,a)||$(this,e,r,t,Math.pow(2,8*t)-1,0);v</span>ar o=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(this[r]=255&amp;e;++n&lt;t&amp;&amp;(o*=256);)<span class="cstat-no" title="statement not covered" >this[r+n]=e/o&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+t}</span>,u.prototype.writeUIntBE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a){<span class="cstat-no" title="statement not covered" >(e=+e,r|=0,t|=0,a)||$(this,e,r,t,Math.pow(2,8*t)-1,0);v</span>ar o=<span class="cstat-no" title="statement not covered" >t-1,</span>n=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>for(this[r+o]=255&amp;e;--o&gt;=0&amp;&amp;(n*=256);)<span class="cstat-no" title="statement not covered" >this[r+o]=e/n&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+t}</span>,u.prototype.writeUInt8=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,1,255,0),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[r]=255&amp;e,r+1}</span>,u.prototype.writeUInt16LE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[r]=255&amp;e,this[r+1]=e&gt;&gt;&gt;8):k(this,e,r,!0),r+2}</span>,u.prototype.writeUInt16BE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[r]=e&gt;&gt;&gt;8,this[r+1]=255&amp;e):k(this,e,r,!1),r+2}</span>,u.prototype.writeUInt32LE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[r+3]=e&gt;&gt;&gt;24,this[r+2]=e&gt;&gt;&gt;16,this[r+1]=e&gt;&gt;&gt;8,this[r]=255&amp;e):I(this,e,r,!0),r+4}</span>,u.prototype.writeUInt32BE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[r]=e&gt;&gt;&gt;24,this[r+1]=e&gt;&gt;&gt;16,this[r+2]=e&gt;&gt;&gt;8,this[r+3]=255&amp;e):I(this,e,r,!1),r+4}</span>,u.prototype.writeIntLE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a){<span class="cstat-no" title="statement not covered" >if(e=+e,r|=0,!a){var o=<span class="cstat-no" title="statement not covered" >Math.pow(2,8*t-1);<span class="cstat-no" title="statement not covered" ></span>$(this,e,r,t,o-1,-o)}</span>v</span>ar n=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >1,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(this[r]=255&amp;e;++n&lt;t&amp;&amp;(s*=256);)<span class="cstat-no" title="statement not covered" >e&lt;0&amp;&amp;0===i&amp;&amp;0!==this[r+n-1]&amp;&amp;(i=1),this[r+n]=(e/s&gt;&gt;0)-i&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+t}</span>,u.prototype.writeIntBE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a){<span class="cstat-no" title="statement not covered" >if(e=+e,r|=0,!a){var o=<span class="cstat-no" title="statement not covered" >Math.pow(2,8*t-1);<span class="cstat-no" title="statement not covered" ></span>$(this,e,r,t,o-1,-o)}</span>v</span>ar n=<span class="cstat-no" title="statement not covered" >t-1,</span>s=<span class="cstat-no" title="statement not covered" >1,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(this[r+n]=255&amp;e;--n&gt;=0&amp;&amp;(s*=256);)<span class="cstat-no" title="statement not covered" >e&lt;0&amp;&amp;0===i&amp;&amp;0!==this[r+n+1]&amp;&amp;(i=1),this[r+n]=(e/s&gt;&gt;0)-i&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+t}</span>,u.prototype.writeInt8=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,1,127,-128),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e&lt;0&amp;&amp;(e=255+e+1),this[r]=255&amp;e,r+1}</span>,u.prototype.writeInt16LE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[r]=255&amp;e,this[r+1]=e&gt;&gt;&gt;8):k(this,e,r,!0),r+2}</span>,u.prototype.writeInt16BE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[r]=e&gt;&gt;&gt;8,this[r+1]=255&amp;e):k(this,e,r,!1),r+2}</span>,u.prototype.writeInt32LE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,4,2147483647,-2147483648),u.TYPED_ARRAY_SUPPORT?(this[r]=255&amp;e,this[r+1]=e&gt;&gt;&gt;8,this[r+2]=e&gt;&gt;&gt;16,this[r+3]=e&gt;&gt;&gt;24):I(this,e,r,!0),r+4}</span>,u.prototype.writeInt32BE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return e=+e,r|=0,t||$(this,e,r,4,2147483647,-2147483648),e&lt;0&amp;&amp;(e=4294967295+e+1),u.TYPED_ARRAY_SUPPORT?(this[r]=e&gt;&gt;&gt;24,this[r+1]=e&gt;&gt;&gt;16,this[r+2]=e&gt;&gt;&gt;8,this[r+3]=255&amp;e):I(this,e,r,!1),r+4}</span>,u.prototype.writeFloatLE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return T(this,e,r,!0,t)}</span>,u.prototype.writeFloatBE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return T(this,e,r,!1,t)}</span>,u.prototype.writeDoubleLE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return M(this,e,r,!0,t)}</span>,u.prototype.writeDoubleBE=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t){<span class="cstat-no" title="statement not covered" >return M(this,e,r,!1,t)}</span>,u.prototype.copy=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a){<span class="cstat-no" title="statement not covered" >if(t||(t=0),a||0===a||(a=this.length),r&gt;=e.length&amp;&amp;(r=e.length),r||(r=0),a&gt;0&amp;&amp;a&lt;t&amp;&amp;(a=t),a===t)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(0===e.length||0===this.length)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(r&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("targetStart out of bounds");<span class="cstat-no" title="statement not covered" >i</span></span>f(t&lt;0||t&gt;=this.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("sourceStart out of bounds");<span class="cstat-no" title="statement not covered" >i</span></span>f(a&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("sourceEnd out of bounds");<span class="cstat-no" title="statement not covered" >a</span></span>&gt;this.length&amp;&amp;(a=this.length),e.length-r&lt;a-t&amp;&amp;(a=e.length-r+t);v</span>ar o,n=<span class="cstat-no" title="statement not covered" >a-t;<span class="cstat-no" title="statement not covered" ></span>if(this===e&amp;&amp;t&lt;r&amp;&amp;r&lt;a)<span class="cstat-no" title="statement not covered" >for(o=n-1;o&gt;=0;--o)<span class="cstat-no" title="statement not covered" >e[o+r]=this[o+t];e</span></span>lse <span class="cstat-no" title="statement not covered" >if(n&lt;1e3||!u.TYPED_ARRAY_SUPPORT)<span class="cstat-no" title="statement not covered" >for(o=0;o&lt;n;++o)<span class="cstat-no" title="statement not covered" >e[o+r]=this[o+t];e</span></span>lse <span class="cstat-no" title="statement not covered" >Uint8Array.prototype.set.call(e,this.subarray(t,t+n),r);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n}</span>,u.prototype.fill=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a){<span class="cstat-no" title="statement not covered" >if("string"==typeof e){<span class="cstat-no" title="statement not covered" >if("string"==typeof r?(a=r,r=0,t=this.length):"string"==typeof t&amp;&amp;(a=t,t=this.length),1===e.length){var o=<span class="cstat-no" title="statement not covered" >e.charCodeAt(0);<span class="cstat-no" title="statement not covered" ></span>o&lt;256&amp;&amp;(e=o)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(void 0!==a&amp;&amp;"string"!=typeof a)<span class="cstat-no" title="statement not covered" >throw new TypeError("encoding must be a string");<span class="cstat-no" title="statement not covered" >i</span></span>f("string"==typeof a&amp;&amp;!u.isEncoding(a))<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+a)}</span></span>else<span class="cstat-no" title="statement not covered" >"number"==typeof e&amp;&amp;(e&amp;=255);<span class="cstat-no" title="statement not covered" >i</span></span>f(r&lt;0||this.length&lt;r||this.length&lt;t)<span class="cstat-no" title="statement not covered" >throw new RangeError("Out of range index");<span class="cstat-no" title="statement not covered" >i</span></span>f(t&lt;=r)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar n;<span class="cstat-no" title="statement not covered" >if(r&gt;&gt;&gt;=0,t=void 0===t?this.length:t&gt;&gt;&gt;0,e||(e=0),"number"==typeof e)<span class="cstat-no" title="statement not covered" >for(n=r;n&lt;t;++n)<span class="cstat-no" title="statement not covered" >this[n]=e;e</span></span>lse{var s=<span class="cstat-no" title="statement not covered" >u.isBuffer(e)?e:z(new u(e,a).toString()),</span>i=<span class="cstat-no" title="statement not covered" >s.length;<span class="cstat-no" title="statement not covered" ></span>for(n=0;n&lt;t-r;++n)<span class="cstat-no" title="statement not covered" >this[n+r]=s[n%i]}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this}</span>;var U=/[^+\/0-9A-Za-z-_]/g;function <span class="fstat-no" title="function not covered" >N(</span>e){<span class="cstat-no" title="statement not covered" >return e&lt;16?"0"+e.toString(16):e.toString(16)}</span>function <span class="fstat-no" title="function not covered" >z(</span>e,r){var t;<span class="cstat-no" title="statement not covered" >r=r||1/0;<span class="cstat-no" title="statement not covered" >f</span>or(var a=e.length,o=null,n=[],s=0;s&lt;a;++s){<span class="cstat-no" title="statement not covered" >if((t=e.charCodeAt(s))&gt;55295&amp;&amp;t&lt;57344){<span class="cstat-no" title="statement not covered" >if(!o){<span class="cstat-no" title="statement not covered" >if(t&gt;56319){<span class="cstat-no" title="statement not covered" >(r-=3)&gt;-1&amp;&amp;n.push(239,191,189);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s+1===a){<span class="cstat-no" title="statement not covered" >(r-=3)&gt;-1&amp;&amp;n.push(239,191,189);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>o</span>=t;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t&lt;56320){<span class="cstat-no" title="statement not covered" >(r-=3)&gt;-1&amp;&amp;n.push(239,191,189),o=t;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>=65536+(o-55296&lt;&lt;10|t-56320)}</span>else <span class="cstat-no" title="statement not covered" >o&amp;&amp;(r-=3)&gt;-1&amp;&amp;n.push(239,191,189);<span class="cstat-no" title="statement not covered" >i</span></span>f(o=null,t&lt;128){<span class="cstat-no" title="statement not covered" >if((r-=1)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>.push(t)}</span>else <span class="cstat-no" title="statement not covered" >if(t&lt;2048){<span class="cstat-no" title="statement not covered" >if((r-=2)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>.push(t&gt;&gt;6|192,63&amp;t|128)}</span>else <span class="cstat-no" title="statement not covered" >if(t&lt;65536){<span class="cstat-no" title="statement not covered" >if((r-=3)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>.push(t&gt;&gt;12|224,t&gt;&gt;6&amp;63|128,63&amp;t|128)}</span>else{<span class="cstat-no" title="statement not covered" >if(!(t&lt;1114112))<span class="cstat-no" title="statement not covered" >throw new Error("Invalid code point");<span class="cstat-no" title="statement not covered" >i</span></span>f((r-=4)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>.push(t&gt;&gt;18|240,t&gt;&gt;12&amp;63|128,t&gt;&gt;6&amp;63|128,63&amp;t|128)}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >L(</span>e){<span class="cstat-no" title="statement not covered" >return a.toByteArray(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if((e=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}</span>(e).replace(U,"")).length&lt;2)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >f</span></span>or(;e.length%4!=0;)<span class="cstat-no" title="statement not covered" >e+="=";<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(e))}</span>function <span class="fstat-no" title="function not covered" >B(</span>e,r,t,a){<span class="cstat-no" title="statement not covered" >for(var o=0;o&lt;a&amp;&amp;!(o+t&gt;=r.length||o&gt;=e.length);++o)<span class="cstat-no" title="statement not covered" >r[o+t]=e[o];<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>}).call(r,t(3))},function(e,r){var t;t=function(){return this}();try{t=t||<span class="branch-1 cbranch-no" title="branch not covered" >Function("return this")()|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >(0,eval)("this")}</span>catch(e){<span class="cstat-no" title="statement not covered" >"object"==typeof window&amp;&amp;(t=window)}</span>e.exports=t},function(e,r,t){"use strict";r.byteLength=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 3*e.length/4-l(e)}</span>,r.toByteArray=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r,t,a,s,i,u=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>s=l(e),i=new n(3*u/4-s),t=s&gt;0?u-4:u;v</span>ar c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(r=0;r&lt;t;r+=4)<span class="cstat-no" title="statement not covered" >a=o[e.charCodeAt(r)]&lt;&lt;18|o[e.charCodeAt(r+1)]&lt;&lt;12|o[e.charCodeAt(r+2)]&lt;&lt;6|o[e.charCodeAt(r+3)],i[c++]=a&gt;&gt;16&amp;255,i[c++]=a&gt;&gt;8&amp;255,i[c++]=255&amp;a;<span class="cstat-no" title="statement not covered" >2</span></span>===s?(a=o[e.charCodeAt(r)]&lt;&lt;2|o[e.charCodeAt(r+1)]&gt;&gt;4,i[c++]=255&amp;a):1===s&amp;&amp;(a=o[e.charCodeAt(r)]&lt;&lt;10|o[e.charCodeAt(r+1)]&lt;&lt;4|o[e.charCodeAt(r+2)]&gt;&gt;2,i[c++]=a&gt;&gt;8&amp;255,i[c++]=255&amp;a);<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>,r.fromByteArray=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r,t=e.length,o=t%3,n="",s=[],i=0,u=t-o;i&lt;u;i+=16383)<span class="cstat-no" title="statement not covered" >s.push(c(e,i,i+16383&gt;u?u:i+16383));<span class="cstat-no" title="statement not covered" >1</span></span>===o?(r=e[t-1],n+=a[r&gt;&gt;2],n+=a[r&lt;&lt;4&amp;63],n+="=="):2===o&amp;&amp;(r=(e[t-2]&lt;&lt;8)+e[t-1],n+=a[r&gt;&gt;10],n+=a[r&gt;&gt;4&amp;63],n+=a[r&lt;&lt;2&amp;63],n+="=");<span class="cstat-no" title="statement not covered" >r</span>eturn s.push(n),s.join("")}</span>;for(var a=[],o=[],n="undefined"!=typeof Uint8Array?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,u=s.length;i&lt;u;++i)a[i]=s[i],o[s.charCodeAt(i)]=i;function <span class="fstat-no" title="function not covered" >l(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>if(r%4&gt;0)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid string. Length must be a multiple of 4");<span class="cstat-no" title="statement not covered" >r</span></span>eturn"="===e[r-2]?2:"="===e[r-1]?1:0}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,r,t){<span class="cstat-no" title="statement not covered" >for(var o,n,s=[],i=r;i&lt;t;i+=3)<span class="cstat-no" title="statement not covered" >o=(e[i]&lt;&lt;16)+(e[i+1]&lt;&lt;8)+e[i+2],s.push(a[(n=o)&gt;&gt;18&amp;63]+a[n&gt;&gt;12&amp;63]+a[n&gt;&gt;6&amp;63]+a[63&amp;n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn s.join("")}</span>o["-".charCodeAt(0)]=62,o["_".charCodeAt(0)]=63},function(e,r){r.read=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a,o){var n,s,i=<span class="cstat-no" title="statement not covered" >8*o-a-1,</span>u=<span class="cstat-no" title="statement not covered" >(1&lt;&lt;i)-1,</span>l=<span class="cstat-no" title="statement not covered" >u&gt;&gt;1,</span>c=<span class="cstat-no" title="statement not covered" >-7,</span>h=<span class="cstat-no" title="statement not covered" >t?o-1:0,</span>f=<span class="cstat-no" title="statement not covered" >t?-1:1,</span>p=<span class="cstat-no" title="statement not covered" >e[r+h];<span class="cstat-no" title="statement not covered" ></span>for(h+=f,n=p&amp;(1&lt;&lt;-c)-1,p&gt;&gt;=-c,c+=i;c&gt;0;n=256*n+e[r+h],h+=f,c-=8);<span class="cstat-no" title="statement not covered" >f</span>or(s=n&amp;(1&lt;&lt;-c)-1,n&gt;&gt;=-c,c+=a;c&gt;0;s=256*s+e[r+h],h+=f,c-=8);<span class="cstat-no" title="statement not covered" >i</span>f(0===n)<span class="cstat-no" title="statement not covered" >n=1-l;e</span>lse{<span class="cstat-no" title="statement not covered" >if(n===u)<span class="cstat-no" title="statement not covered" >return s?NaN:1/0*(p?-1:1);<span class="cstat-no" title="statement not covered" >s</span></span>+=Math.pow(2,a),n-=l}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn(p?-1:1)*s*Math.pow(2,n-a)}</span>,r.write=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,t,a,o,n){var s,i,u,l=<span class="cstat-no" title="statement not covered" >8*n-o-1,</span>c=<span class="cstat-no" title="statement not covered" >(1&lt;&lt;l)-1,</span>h=<span class="cstat-no" title="statement not covered" >c&gt;&gt;1,</span>f=<span class="cstat-no" title="statement not covered" >23===o?Math.pow(2,-24)-Math.pow(2,-77):0,</span>p=<span class="cstat-no" title="statement not covered" >a?0:n-1,</span>d=<span class="cstat-no" title="statement not covered" >a?1:-1,</span>m=<span class="cstat-no" title="statement not covered" >r&lt;0||0===r&amp;&amp;1/r&lt;0?1:0;<span class="cstat-no" title="statement not covered" ></span>for(r=Math.abs(r),isNaN(r)||r===1/0?(i=isNaN(r)?1:0,s=c):(s=Math.floor(Math.log(r)/Math.LN2),r*(u=Math.pow(2,-s))&lt;1&amp;&amp;(s--,u*=2),(r+=s+h&gt;=1?f/u:f*Math.pow(2,1-h))*u&gt;=2&amp;&amp;(s++,u/=2),s+h&gt;=c?(i=0,s=c):s+h&gt;=1?(i=(r*u-1)*Math.pow(2,o),s+=h):(i=r*Math.pow(2,h-1)*Math.pow(2,o),s=0));o&gt;=8;e[t+p]=255&amp;i,p+=d,i/=256,o-=8);<span class="cstat-no" title="statement not covered" >f</span>or(s=s&lt;&lt;o|i,l+=o;l&gt;0;e[t+p]=255&amp;s,p+=d,s/=256,l-=8);<span class="cstat-no" title="statement not covered" >e</span>[t+p-d]|=128*m}</span>},function(e,r){var t={}.toString;e.exports=Array.isArray||<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"[object Array]"==t.call(e)}</span>}</span>,function(e,r,t){"use strict";var a=t(1);const o=<span class="fstat-no" title="function not covered" >(e</span>,r,t)=&gt;{let a=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >e&lt;r,</span>n=<span class="cstat-no" title="statement not covered" >t?o?r+1:r-1:r;<span class="cstat-no" title="statement not covered" ></span>for(let r=e;o?r&lt;n:r&gt;n;o?r++:r--)<span class="cstat-no" title="statement not covered" >a.push(r);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>;r.a=class{<span class="fstat-no" title="function not covered" >st</span>atic getTypeOf(e){<span class="cstat-no" title="statement not covered" >return Object.prototype.toString.call(e).slice(8,-1)}<span class="fstat-no" title="function not covered" ></span>st</span>atic isOfType(e,r){<span class="cstat-no" title="statement not covered" >return this.getTypeOf(e)===a.a.getFunctionName(r)||e instanceof r}<span class="fstat-no" title="function not covered" ></span>st</span>atic objectToQuery(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let r=<span class="cstat-no" title="statement not covered" >[],</span>t=<span class="cstat-no" title="statement not covered" >Object.keys(e);<span class="cstat-no" title="statement not covered" ></span>for(let a of o(0,t.length-1,!0))<span class="cstat-no" title="statement not covered" >r[a]=[t[a],e[t[a]]];<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.map(<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.join("="))</span>.join("&amp;")}<span class="fstat-no" title="function not covered" ></span>st</span>atic queryToObject(e){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return decodeURIComponent(e).replace("?","").split("&amp;").forEach(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let a;<span class="cstat-no" title="statement not covered" >if(2===(a=e.split("=")).length)<span class="cstat-no" title="statement not covered" >return r[a[0]]=a[1]}</span></span>),r}</span>}},function(e,r,t){"use strict";r.a=class{<span class="fstat-no" title="function not covered" >st</span>atic capitalize(e){<span class="cstat-no" title="statement not covered" >return null===e?"":("string"!=typeof e&amp;&amp;(e=e.toString()),e.split(/[\s]{1,}/).map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >`${e.charAt(0).toUpperCase()}${e.slice(1)}`)</span>.join(" "))}<span class="fstat-no" title="function not covered" ></span>st</span>atic stripNull(e){<span class="cstat-no" title="statement not covered" >return void 0===e?"":e.replace(/\0/g,"")}<span class="fstat-no" title="function not covered" ></span>st</span>atic regexEscape(e){<span class="cstat-no" title="statement not covered" >return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&amp;")}</span>}}])},e.exports=a()},function(e,r,t){e.exports=t(60)},function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0});var a=t(8);Object.defineProperty(r,"RxVO",{enumerable:!0,get:function(){return a.RxVO}}),"function"!=typeof Object.assign&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >Object.assign=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(null==e)<span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot convert undefined or null to object");<span class="cstat-no" title="statement not covered" >e</span></span>=Object(e);<span class="cstat-no" title="statement not covered" >f</span>or(var r=1;r&lt;arguments.length;){var t=<span class="cstat-no" title="statement not covered" >arguments[r];<span class="cstat-no" title="statement not covered" ></span>if(null!==t)<span class="cstat-no" title="statement not covered" >for(var a in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,a)&amp;&amp;(e[a]=t[a]);<span class="cstat-no" title="statement not covered" >r</span></span></span>+=1}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>)</span>}]);</pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Sat Apr 21 2018 12:52:49 GMT-0500 (CDT)
</div>
</div>
<script src="../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../sorter.js"></script>
</body>
</html>
