<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/classes/_schemaValidator.js | jsd</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Schema Generation and Data Validation with object virtualization"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="jsd"><meta property="twitter:description" content="Schema Generation and Data Validation with object virtualization"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Webfreshener/JSD.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#classes">classes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/_metaData.js~MetaData.html">MetaData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/_observerBuilder.js~ObserverBuilder.html">ObserverBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/_schemaHelpers.js~SchemaHelpers.html">SchemaHelpers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/_schemaValidator.js~SchemaValidator.html">SchemaValidator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/_validatorBuilder.js~ValidatorBuilder.html">ValidatorBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/_validators.js~BaseValidator.html">BaseValidator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/jsd.js~JSD.html">JSD</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/model.js~Model.html">Model</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/schema.js~Schema.html">Schema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/classes/set.js~Set.html">Set</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ensureKindIsString">ensureKindIsString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ensureRequiredFields">ensureRequiredFields</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-remapPolypath">remapPolypath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_exists">_exists</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_kinds">_kinds</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_mdRef">_mdRef</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_oBuilders">_oBuilders</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_object">_object</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_observers">_observers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_required_elements">_required_elements</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_schemaHelpers">_schemaHelpers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_schemaOptions">_schemaOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_schemaSignatures">_schemaSignatures</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_singletons">_singletons</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_vBuilders">_vBuilders</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_vPaths">_vPaths</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_validPaths">_validPaths</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_validators">_validators</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-_vectorTypes">_vectorTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-wf">wf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-rxRx">rxRx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Validator">Validator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/classes/_schemaValidator.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {wf, _exists, _schemaOptions, _vBuilders} from &quot;./_references&quot;;

/**
 * @private
 * @class
 */
export class SchemaValidator {
    /**
     *
     * @param _schema {object}
     * @param opts {object}
     */
    constructor(_schema = {}, opts = {extensible: false}) {
        let _errorMsg;
        _schemaOptions.set(this, opts);
        Object.defineProperty(this, &quot;isValid&quot;, {
            get: () =&gt; _errorMsg || true,
            enumerable: false,
        });
        // schema is expected to be object
        if ((typeof _schema) !== &quot;object&quot;) {
            try {
                // attempts to parse JSON formatted string...
                _schema = JSON.parse(_schema.toString());
            } catch (e) {
                // throws error and aborts if parsing failed
                throw &quot;Schema was invalid. JSON object or formatted string is required&quot;;
            }
        }
        // inits validation of Schema entries
        _errorMsg = SchemaValidator.eval(_schema, this);
    }

    /**
     *  @param {string} key
     *  @param {string} _type
     */
    validateTypeString(key, _type) {
        //- ignores special `default` object key
        if (key.match(/\.?default+$/)) {
            return true;
        }
        //- handles restrictions defined in `restrict` object key
        if (key.match(/\.?restrict+$/)) {
            if (typeof _type !== &quot;string&quot; || !_type.length) {
                return &quot;restrict requires a Regular Expression String&quot;;
            }
            try {
                //- tests for valid RegExp string
                &quot;text&quot;.match(new RegExp(_type));
            }
            catch (e) {
                return `Regular Expression provided for &apos;${key}&apos; was invalid. ${e}`;
            }
        }
        //- tests for basic string type declaration {key: {type: &quot;String&quot;} }
        else {
            if (!_exists(this.jsd.getClass(wf.Str.capitalize(_type)))) {
                return `type &apos;&lt;${_type}&gt;&apos; for schema element &apos;${key}&apos; was invalid`;
            }
        }
        return true;
    }

    /**
     *
     * @param key
     * @param params
     * @returns {boolean|string}
     */
    validateUntypedMembers(key, params) {
        if (Array.isArray(params)) {
            for (let item of params) {
                let _res;
                if (typeof (_res = this.validateSchemaEntry(`${key}`, item)) === &quot;string&quot;) {
                    return _res;
                }
            }
        }
        else {
            let _p;
            let keyPath;
            if ((_p = (keyPath = key.split(&quot;.&quot;)).pop()) !== &quot;elements&quot;) {
                if (_p === &quot;default&quot;) {
                    return true;
                }
                if (Array.isArray(params)) {
                    params = {polymorphic: params};
                }
                if (params.hasOwnProperty(&quot;polymorphic&quot;)) {
                    return this.validatePolymorphicEntry(`${key}.polymorphic`, params.polymorphic);
                }
                return `value for schema element &apos;${key}&apos; was malformed. Property &apos;type&apos; was missing`;
            }
            else {
                for (let param of Object.keys(params)) {
                    let _res;
                    let _keys = [].concat(keyPath).concat(param);
                    if (typeof (_res = this.validateSchemaEntry(`${_keys.join(&quot;.&quot;)}`, params[param])) === &quot;string&quot;) {
                        return _res;
                    }
                }
            }
        }
        return true;
    }

    /**
     *
     * @param key
     * @param params
     * @returns {boolean|string}
     */
    validateSchemaClass(key, params) {
        if (!_exists(key)) {
            throw &quot;key was undefined&quot;;
        }
        if (typeof key !== &quot;string&quot;) {
            throw `string expected for argument &apos;key&apos;. Type was &apos;&lt;${typeof key}&gt;&apos;`;
        }
        if (!_exists(params)) {
            throw &quot;params was undefined&quot;;
        }
        if (typeof params !== &quot;object&quot;) {
            throw `object expected for argument &apos;params&apos;. Type was &apos;&lt;${typeof params}&gt;&apos;`;
        }
        if (params.type === &quot;*&quot;) {
            return true;
        }
        if (Object.keys(params).length === 0) {
            return true;
        }
        if (typeof params.type === &quot;object&quot;) {
            return this.validateSchemaEntry(key, params.type);
        }
        if (key.split(&quot;.&quot;).pop() === &quot;default&quot;) {
            if (this._defaults == null) {
                this._defaults = {};
            }
            this._defaults[key] = params;
            return true;
        }
        return `value for schema element &apos;${key}&apos; has invalid type &apos;&lt;${params.type}&gt;&apos;`;
    }

    /**
     * @param {string} key
     * @param {string} sKey
     * @param {object} params
     */
    validateSchemaParamString(key, sKey, params) {
        let _schemaKeys = this.jsd.schemaRef;
        let opts = _schemaOptions.get(this);
        // handles special `restrict` key
        if (sKey === &quot;restrict&quot;) {
            try {
                new RegExp(params[sKey]);
            }
            catch (e) {
                return e;
            }
            return true;
        }
        // rejects values for keys not found in Schema
        if (sKey !== &quot;*&quot; &amp;&amp; !_exists(_schemaKeys[sKey]) &amp;&amp;
            opts.extensible === false) {
            return `schema element &apos;${key}.${sKey}&apos; is not allowed`;
        }
        let eMsg = this.validateTypeString(`${key}.${sKey}`, params[sKey]);
        if (typeof eMsg === &quot;string&quot;) {
            return eMsg;
        }
        _vBuilders.get(this.jsd).create(params, key);
        return true;
    }

    /**
     *
     * @param key
     * @param sKey
     * @param _schemaKeys
     * @param params
     * @returns {boolean|string}
     */
    validateSchemaParam(key, sKey, _schemaKeys, params) {
        let _type;
        let eMsg;
        // rejects unknown element if schema non-extensible
        if (sKey !== &quot;*&quot; &amp;&amp; !_exists(_schemaKeys[sKey]) &amp;&amp;
            !_schemaOptions.get(this).extensible) {
            return `schema element &apos;${key}.${sKey}&apos; is not allowed`;
        }
        // returns result of Params String Validation
        if (typeof params[sKey] === &quot;string&quot;) {
            let eMsg = this.validateSchemaParamString(key, sKey, params);
            if (typeof eMsg === &quot;string&quot;) {
                return eMsg;
            }
        }

        if (sKey === &quot;polymorphic&quot;) {
            return this.validatePolymorphicEntry(key, params);
        }

        // returns result of
        if (typeof _schemaKeys[sKey] === &quot;object&quot;) {
            // handles `elements` object
            if (sKey === &quot;elements&quot;) {
                let _iterate = Array.isArray(params.elements) ? params.elements : Object.keys(params.elements);
                for (let xKey of _iterate) {
                    if (typeof xKey === &quot;string&quot;) {
                        eMsg = this.validateSchemaEntry(`${key}.${xKey}`, params.elements[xKey]);
                        if (typeof eMsg === &quot;string&quot;) {
                            return eMsg;
                        }
                    } else {
                        eMsg = this.validateSchemaParam(key, xKey.type, _schemaKeys, params.elements);
                        if (typeof eMsg === &quot;string&quot;) {
                            return eMsg;
                        }
                    }
                }
                return true;
            }
            // attempts to handle Native Types
            else {
                _type = _schemaKeys[sKey].type;
                if (!_exists(_type)) {
                    return `type attribute was not defined for ${key}`;
                }

                if (!Array.isArray(_type)) {
                    _type = _type.type;
                }

                if (params.type === &quot;*&quot;) {
                    return true;
                } else if (_type.indexOf(params.type) &lt; 0) {
                    return `type attribute was not defined for ${sKey}`;
                }
            }
        }
        // creates validator for all paths that pass schema validation
        _vBuilders.get(this.jsd).create(params, key);
        return true;
    }

    /**
     *
     * @param key
     * @param params
     * @param opts
     * @returns {boolean|string}
     */
    validateSchemaEntry(key, params, opts) {
        let _schemaKeys = this.jsd.schemaRef;
        if (!_exists(opts)) {
            opts = _schemaOptions.get(this);
        }
        if (key === &quot;polymorphic&quot;) {
            return this.validatePolymorphicEntry(`${key}`, params, opts);
        }
        if (!_exists(params)) {
            return `${key} was null or undefined`;
        }
        if ((typeof params) === &quot;boolean&quot;) {
            return true;
        }
        if ((typeof params) === &quot;string&quot;) {
            return this.validateTypeString(`${key}`, params);
        }
        if ((typeof params) === &quot;object&quot;) {
            // handled Objects with no `type` element
            if (!params.hasOwnProperty(&quot;type&quot;)) {
                return this.validateUntypedMembers(key, params);
            }
            // handles Classes/Functions
            if ((this.jsd.getClass(params.type)) === null) {
                return this.validateSchemaClass(key, params);
            }

            if (params.type === &quot;Array&quot;) {
                // Arrays are dealt with as polymorphic elements internally
                if (params.hasOwnProperty(&quot;elements&quot;)) {
                    params.polymorphic = Array.isArray(params.elements) ?
                        [].concat(params.elements) : [Object.assign({}, params.elements)];
                    delete params.elements;
                }
                _vBuilders.get(this.jsd).create(params, key);
                key = `${key}.*.polymorphic`;

                if (params.hasOwnProperty(&quot;polymorphic&quot;)) {
                    if (!Array.isArray(params.polymorphic)) {
                        params.polymorphic = [params.elements];
                    }
                    return this.validatePolymorphicEntry(key, params.polymorphic);
                }
            }

            // handles child elements
            for (let sKey of Object.keys(params)) {
                let __ = this.validateSchemaParam(key, sKey, _schemaKeys, params);
                if (typeof __ === &quot;string&quot;) {
                    return __;
                }
            }
            return true;
        }
        // handles non-object entries (Function, String, Number, Boolean, ...)
        else {
            let _t = typeof params;
            if (_t !== &quot;function&quot;) {
                let _ = _schemaKeys[key.split(&quot;.&quot;).pop()];
                // tests for everything that&quot;s not a string, _object or function
                if (_ !== wf.Str.capitalize(_t)) {
                    return `value for schema element &apos;${key}&apos; has invalid type :: &quot;&lt;${_t}&gt;&quot;`;
                }
            }
            else {
                let _ = wf.Fun.getConstructorName(params);
                // tests for function&quot;s constructor name
                if (_ !== _schemaKeys[key]) {
                    return `value for schema element &apos;${key}&apos; has invalid class or method &quot;&lt;${_}&gt;&quot;`;
                }
            }
            return true;
        }
    }

    /**
     *
     * @param key
     * @param params
     * @param opts
     * @returns {boolean|string}
     */
    validatePolymorphicEntry(key, params, opts) {
        let cnt = 0;
        try {
            params.forEach((entry) =&gt; {
                let itmKey = `${key}.${cnt}`;
                let e = this.validateSchemaEntry(itmKey, entry, opts);
                if ((typeof e) === &quot;string&quot;) {
                    throw e;
                }
                _vBuilders.get(this.jsd).create(entry, itmKey);
                cnt++;
            });
        } catch (e) {
            return e;
        }

        return true;
    }

    /**
     *
     * @returns {JSD}
     */
    get jsd() {
        return _schemaOptions.get(this).jsd;
    }

    /**
     *
     * @param _schema
     * @param caller
     * @returns {boolean}
     */
    static eval(_schema, caller) {
        let _errorMsg = true;
        let _iterate = Array.isArray(_schema) ? _schema : Object.keys(_schema);
        for (let _oKey of _iterate) {
            if (_oKey &amp;&amp; typeof _oKey === &quot;object&quot;) {
                let e = SchemaValidator.eval(_oKey, caller);
                if (typeof e === &quot;string&quot;) {
                    _errorMsg = e;
                    break;
                }
                break;
            }
            switch (typeof _schema[_oKey]) {
                case &quot;string&quot;:
                    _errorMsg = caller.validateSchemaEntry(_oKey, _schema[_oKey]);
                    break;
                case &quot;object&quot;:
                    if (!Array.isArray(_schema[_oKey])) {
                        if (_oKey !== &quot;elements&quot;) {
                            _errorMsg = caller.validateSchemaEntry(_oKey, _schema[_oKey]);
                        }
                        else {
                            for (let _x of Object.keys(_schema[_oKey])) {
                                if (typeof (_errorMsg = caller.validateSchemaEntry(_x, _schema[_oKey][_x])) === &quot;string&quot;) {
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        if (_oKey === &quot;polymorphic&quot;) {
                            return caller.validatePolymorphicEntry(_oKey, _schema[_oKey]);
                        }
                        for (let _s of _schema[_oKey]) {
                            if (typeof _schema[_oKey][_s] === &quot;string&quot;) {
                                _errorMsg = caller.validateTypeString(_oKey, _s);
                            }
                            else {
                                _errorMsg = caller.validateSchemaEntry(_oKey, _s);
                            }
                            if ((typeof _errorMsg) === &quot;string&quot;) {
                                return _errorMsg;
                            }
                        }
                    }
                    break;
                case &quot;boolean&quot;:
                    _errorMsg = caller.validateSchemaEntry(_oKey, _schema[_oKey]);
                    break;
                default:
                    _errorMsg = `value for schema element &apos;${_oKey}&apos; was invalid`;
            }
            if ((typeof _errorMsg) === &quot;string&quot;) {
                return _errorMsg;
            }
        }
        return _errorMsg;
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
